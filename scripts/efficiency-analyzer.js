#!/usr/bin/env node

/**
 * íš¨ìœ¨ì„± ë¶„ì„ê¸°
 * 
 * ì´ ìŠ¤í¬ë¦½íŠ¸ëŠ” ë‹¤ìŒì„ ë¶„ì„í•©ë‹ˆë‹¤:
 * 1. í˜„ì¬ ì‹œìŠ¤í…œì˜ ë²„ê·¸ ê°ì§€ íš¨ìœ¨ì„±
 * 2. TODO ìƒì„± ì •í™•ë„
 * 3. ìë™í™” ìˆ˜ì¤€
 * 4. ê°œì„  í•„ìš” ì˜ì—­
 */

const fs = require('fs').promises
const path = require('path')

class EfficiencyAnalyzer {
    constructor() {
        this.analysisResults = {
            bugDetection: {},
            todoGeneration: {},
            automation: {},
            improvements: {}
        }
    }

    async analyze() {
        console.log('ğŸ“Š ì‹œìŠ¤í…œ íš¨ìœ¨ì„± ë¶„ì„ ì‹œì‘...')

        try {
            // 1. ë²„ê·¸ ê°ì§€ íš¨ìœ¨ì„± ë¶„ì„
            await this.analyzeBugDetection()

            // 2. TODO ìƒì„± íš¨ìœ¨ì„± ë¶„ì„
            await this.analyzeTodoGeneration()

            // 3. ìë™í™” ìˆ˜ì¤€ ë¶„ì„
            await this.analyzeAutomation()

            // 4. ê°œì„  ë°©ì•ˆ ì œì‹œ
            await this.generateImprovements()

            // 5. ê²°ê³¼ ì¶œë ¥
            this.displayResults()

        } catch (error) {
            console.error('âŒ ë¶„ì„ ì˜¤ë¥˜:', error.message)
        }
    }

    async analyzeBugDetection() {
        console.log('ğŸ› ë²„ê·¸ ê°ì§€ íš¨ìœ¨ì„± ë¶„ì„...')

        const bugStats = {
            totalDetected: 0,
            criticalBugs: 0,
            highBugs: 0,
            mediumBugs: 0,
            lowBugs: 0,
            falsePositives: 0,
            missedBugs: 0
        }

        // TODO íŒŒì¼ì—ì„œ ë²„ê·¸ í†µê³„ ìˆ˜ì§‘
        try {
            const content = await fs.readFile('docs/todo-backlog.md', 'utf8')
            const lines = content.split('\n')

            for (const line of lines) {
                if (line.includes('ğŸ›') && line.includes('|')) {
                    bugStats.totalDetected++

                    if (line.includes('critical')) bugStats.criticalBugs++
                    else if (line.includes('high')) bugStats.highBugs++
                    else if (line.includes('medium')) bugStats.mediumBugs++
                    else if (line.includes('low')) bugStats.lowBugs++
                }
            }
        } catch (error) {
            console.warn('âš ï¸ TODO íŒŒì¼ ë¶„ì„ ì‹¤íŒ¨:', error.message)
        }

        // ë¡œê·¸ íŒŒì¼ì—ì„œ ì‹¤ì œ ì—ëŸ¬ í™•ì¸
        const logFiles = ['logs/runtime.log', 'logs/auto-progress.log']
        let actualErrors = 0

        for (const logFile of logFiles) {
            try {
                const content = await fs.readFile(logFile, 'utf8')
                const errorLines = content.split('\n').filter(line =>
                    line.includes('ERROR') ||
                    line.includes('WARN') ||
                    line.includes('Exception') ||
                    line.includes('Failed')
                )
                actualErrors += errorLines.length
            } catch (err) {
                // íŒŒì¼ì´ ì—†ìœ¼ë©´ ë¬´ì‹œ
            }
        }

        // íš¨ìœ¨ì„± ê³„ì‚°
        const detectionRate = actualErrors > 0 ? (bugStats.totalDetected / actualErrors) * 100 : 0
        const criticalDetectionRate = bugStats.criticalBugs > 0 ? (bugStats.criticalBugs / bugStats.totalDetected) * 100 : 0

        this.analysisResults.bugDetection = {
            ...bugStats,
            actualErrors,
            detectionRate: Math.round(detectionRate),
            criticalDetectionRate: Math.round(criticalDetectionRate),
            efficiency: this.calculateEfficiency(detectionRate, criticalDetectionRate)
        }
    }

    async analyzeTodoGeneration() {
        console.log('ğŸ“ TODO ìƒì„± íš¨ìœ¨ì„± ë¶„ì„...')

        const todoStats = {
            totalGenerated: 0,
            autoGenerated: 0,
            manualCreated: 0,
            completed: 0,
            inProgress: 0,
            pending: 0,
            duplicates: 0
        }

        try {
            const content = await fs.readFile('docs/todo-backlog.md', 'utf8')
            const lines = content.split('\n')

            for (const line of lines) {
                if (line.includes('|') && (line.includes('â¬œ') || line.includes('ğŸŸ¨') || line.includes('âœ…'))) {
                    todoStats.totalGenerated++

                    if (line.includes('ğŸ¤–')) todoStats.autoGenerated++
                    else todoStats.manualCreated++

                    if (line.includes('âœ…')) todoStats.completed++
                    else if (line.includes('ğŸŸ¨')) todoStats.inProgress++
                    else if (line.includes('â¬œ')) todoStats.pending++
                }
            }

            // ì¤‘ë³µ TODO ê°ì§€ (ê°„ë‹¨í•œ ì œëª© ë¹„êµ)
            const titles = lines
                .filter(line => line.includes('|') && line.includes('â¬œ'))
                .map(line => line.split('|')[1]?.trim())
                .filter(title => title)

            const uniqueTitles = new Set(titles)
            todoStats.duplicates = titles.length - uniqueTitles.size

        } catch (error) {
            console.warn('âš ï¸ TODO ë¶„ì„ ì‹¤íŒ¨:', error.message)
        }

        // íš¨ìœ¨ì„± ê³„ì‚°
        const completionRate = todoStats.totalGenerated > 0 ? (todoStats.completed / todoStats.totalGenerated) * 100 : 0
        const autoGenerationRate = todoStats.totalGenerated > 0 ? (todoStats.autoGenerated / todoStats.totalGenerated) * 100 : 0
        const duplicateRate = todoStats.totalGenerated > 0 ? (todoStats.duplicates / todoStats.totalGenerated) * 100 : 0

        this.analysisResults.todoGeneration = {
            ...todoStats,
            completionRate: Math.round(completionRate),
            autoGenerationRate: Math.round(autoGenerationRate),
            duplicateRate: Math.round(duplicateRate),
            efficiency: this.calculateTodoEfficiency(completionRate, autoGenerationRate, duplicateRate)
        }
    }

    async analyzeAutomation() {
        console.log('ğŸ¤– ìë™í™” ìˆ˜ì¤€ ë¶„ì„...')

        const automationStats = {
            scriptsAvailable: 0,
            scriptsWorking: 0,
            scheduledTasks: 0,
            realTimeMonitoring: false,
            autoAssignment: false,
            autoProgressTracking: false
        }

        // ìŠ¤í¬ë¦½íŠ¸ íŒŒì¼ í™•ì¸
        const scriptFiles = [
            'scripts/auto-todo-generator.js',
            'scripts/auto-task-assigner.js',
            'scripts/auto-progress-tracker.js',
            'scripts/manager-centric-system.js',
            'scripts/ai-escalation-system.js',
            'scripts/ai-integration.js'
        ]

        for (const script of scriptFiles) {
            try {
                await fs.access(script)
                automationStats.scriptsAvailable++

                // ìŠ¤í¬ë¦½íŠ¸ê°€ ì‹¤í–‰ ê°€ëŠ¥í•œì§€ í™•ì¸ (ê°„ë‹¨í•œ ë¬¸ë²• ì²´í¬)
                const content = await fs.readFile(script, 'utf8')
                if (content.includes('class ') && content.includes('async ')) {
                    automationStats.scriptsWorking++
                }
            } catch (err) {
                // íŒŒì¼ì´ ì—†ê±°ë‚˜ ì½ì„ ìˆ˜ ì—†ìŒ
            }
        }

        // GitHub Actions í™•ì¸
        try {
            await fs.access('.github/workflows/auto-development.yml')
            automationStats.scheduledTasks++
        } catch (err) {
            // íŒŒì¼ì´ ì—†ìŒ
        }

        // ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ í™•ì¸
        try {
            const content = await fs.readFile('scripts/manager-centric-system.js', 'utf8')
            if (content.includes('--mode=monitor')) {
                automationStats.realTimeMonitoring = true
            }
        } catch (err) {
            // íŒŒì¼ì´ ì—†ìŒ
        }

        // ìë™ í• ë‹¹ í™•ì¸
        try {
            const content = await fs.readFile('scripts/auto-task-assigner.js', 'utf8')
            if (content.includes('assignTasks')) {
                automationStats.autoAssignment = true
            }
        } catch (err) {
            // íŒŒì¼ì´ ì—†ìŒ
        }

        // ìë™ ì§„í–‰ ì¶”ì  í™•ì¸
        try {
            const content = await fs.readFile('scripts/auto-progress-tracker.js', 'utf8')
            if (content.includes('analyzeProgress')) {
                automationStats.autoProgressTracking = true
            }
        } catch (err) {
            // íŒŒì¼ì´ ì—†ìŒ
        }

        // ìë™í™” ìˆ˜ì¤€ ê³„ì‚°
        const automationScore = this.calculateAutomationScore(automationStats)

        this.analysisResults.automation = {
            ...automationStats,
            automationScore,
            level: this.getAutomationLevel(automationScore)
        }
    }

    async generateImprovements() {
        console.log('ğŸ’¡ ê°œì„  ë°©ì•ˆ ìƒì„±...')

        const improvements = []

        // ë²„ê·¸ ê°ì§€ ê°œì„ 
        if (this.analysisResults.bugDetection.detectionRate < 70) {
            improvements.push({
                category: 'bug_detection',
                priority: 'high',
                title: 'ë²„ê·¸ ê°ì§€ìœ¨ í–¥ìƒ',
                description: `í˜„ì¬ ê°ì§€ìœ¨ ${this.analysisResults.bugDetection.detectionRate}%ë¥¼ 90% ì´ìƒìœ¼ë¡œ í–¥ìƒ`,
                action: 'ë¡œê·¸ íŒ¨í„´ ë¶„ì„ ê°•í™”, ìƒˆë¡œìš´ ì—ëŸ¬ íƒ€ì… ê°ì§€ ë¡œì§ ì¶”ê°€'
            })
        }

        // TODO ìƒì„± ê°œì„ 
        if (this.analysisResults.todoGeneration.duplicateRate > 10) {
            improvements.push({
                category: 'todo_generation',
                priority: 'medium',
                title: 'ì¤‘ë³µ TODO ì œê±°',
                description: `í˜„ì¬ ì¤‘ë³µë¥  ${this.analysisResults.todoGeneration.duplicateRate}%ë¥¼ 5% ì´í•˜ë¡œ ê°ì†Œ`,
                action: 'ì¤‘ë³µ ê°ì§€ ì•Œê³ ë¦¬ì¦˜ ê°œì„ , TODO ì •ê·œí™” ë¡œì§ ì¶”ê°€'
            })
        }

        // ìë™í™” ê°œì„ 
        if (this.analysisResults.automation.automationScore < 70) {
            improvements.push({
                category: 'automation',
                priority: 'high',
                title: 'ìë™í™” ìˆ˜ì¤€ í–¥ìƒ',
                description: `í˜„ì¬ ìë™í™” ì ìˆ˜ ${this.analysisResults.automation.automationScore}%ë¥¼ 90% ì´ìƒìœ¼ë¡œ í–¥ìƒ`,
                action: 'ìŠ¤í¬ë¦½íŠ¸ ì•ˆì •ì„± ê°œì„ , ìŠ¤ì¼€ì¤„ë§ ìµœì í™”, ëª¨ë‹ˆí„°ë§ ê°•í™”'
            })
        }

        // ì„±ëŠ¥ ê°œì„ 
        improvements.push({
            category: 'performance',
            priority: 'medium',
            title: 'ì‹œìŠ¤í…œ ì„±ëŠ¥ ìµœì í™”',
            description: 'ì²˜ë¦¬ ì†ë„ ë° ë¦¬ì†ŒìŠ¤ ì‚¬ìš©ëŸ‰ ìµœì í™”',
            action: 'ìºì‹± ë„ì…, ë³‘ë ¬ ì²˜ë¦¬ ê°œì„ , ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ìµœì í™”'
        })

        this.analysisResults.improvements = improvements
    }

    calculateEfficiency(detectionRate, criticalDetectionRate) {
        // ë²„ê·¸ ê°ì§€ íš¨ìœ¨ì„± ê³„ì‚° (0-100)
        const baseScore = Math.min(detectionRate, 100)
        const criticalBonus = criticalDetectionRate * 0.2
        return Math.min(Math.round(baseScore + criticalBonus), 100)
    }

    calculateTodoEfficiency(completionRate, autoGenerationRate, duplicateRate) {
        // TODO íš¨ìœ¨ì„± ê³„ì‚° (0-100)
        const baseScore = (completionRate + autoGenerationRate) / 2
        const duplicatePenalty = duplicateRate * 0.5
        return Math.max(Math.round(baseScore - duplicatePenalty), 0)
    }

    calculateAutomationScore(stats) {
        let score = 0

        // ìŠ¤í¬ë¦½íŠ¸ ê°€ìš©ì„± (30ì )
        score += (stats.scriptsWorking / stats.scriptsAvailable) * 30

        // ìŠ¤ì¼€ì¤„ë§ (20ì )
        score += stats.scheduledTasks * 20

        // ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ (20ì )
        score += stats.realTimeMonitoring ? 20 : 0

        // ìë™ í• ë‹¹ (15ì )
        score += stats.autoAssignment ? 15 : 0

        // ìë™ ì§„í–‰ ì¶”ì  (15ì )
        score += stats.autoProgressTracking ? 15 : 0

        return Math.round(score)
    }

    getAutomationLevel(score) {
        if (score >= 90) return 'Expert'
        if (score >= 70) return 'Advanced'
        if (score >= 50) return 'Intermediate'
        if (score >= 30) return 'Basic'
        return 'Beginner'
    }

    displayResults() {
        console.log('\n' + '='.repeat(60))
        console.log('ğŸ“Š ì‹œìŠ¤í…œ íš¨ìœ¨ì„± ë¶„ì„ ê²°ê³¼')
        console.log('='.repeat(60))

        // ë²„ê·¸ ê°ì§€ íš¨ìœ¨ì„±
        const bug = this.analysisResults.bugDetection
        console.log('\nğŸ› ë²„ê·¸ ê°ì§€ íš¨ìœ¨ì„±:')
        console.log(`  â€¢ ì´ ê°ì§€ëœ ë²„ê·¸: ${bug.totalDetected}ê°œ`)
        console.log(`  â€¢ ì‹¤ì œ ì—ëŸ¬: ${bug.actualErrors}ê°œ`)
        console.log(`  â€¢ ê°ì§€ìœ¨: ${bug.detectionRate}%`)
        console.log(`  â€¢ íš¨ìœ¨ì„± ì ìˆ˜: ${bug.efficiency}/100`)

        // TODO ìƒì„± íš¨ìœ¨ì„±
        const todo = this.analysisResults.todoGeneration
        console.log('\nğŸ“ TODO ìƒì„± íš¨ìœ¨ì„±:')
        console.log(`  â€¢ ì´ ìƒì„±ëœ TODO: ${todo.totalGenerated}ê°œ`)
        console.log(`  â€¢ ìë™ ìƒì„±: ${todo.autoGenerated}ê°œ (${todo.autoGenerationRate}%)`)
        console.log(`  â€¢ ì™„ë£Œìœ¨: ${todo.completionRate}%`)
        console.log(`  â€¢ ì¤‘ë³µë¥ : ${todo.duplicateRate}%`)
        console.log(`  â€¢ íš¨ìœ¨ì„± ì ìˆ˜: ${todo.efficiency}/100`)

        // ìë™í™” ìˆ˜ì¤€
        const auto = this.analysisResults.automation
        console.log('\nğŸ¤– ìë™í™” ìˆ˜ì¤€:')
        console.log(`  â€¢ ì‚¬ìš© ê°€ëŠ¥í•œ ìŠ¤í¬ë¦½íŠ¸: ${auto.scriptsAvailable}ê°œ`)
        console.log(`  â€¢ ì‘ë™í•˜ëŠ” ìŠ¤í¬ë¦½íŠ¸: ${auto.scriptsWorking}ê°œ`)
        console.log(`  â€¢ ìŠ¤ì¼€ì¤„ëœ ì‘ì—…: ${auto.scheduledTasks}ê°œ`)
        console.log(`  â€¢ ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§: ${auto.realTimeMonitoring ? 'âœ…' : 'âŒ'}`)
        console.log(`  â€¢ ìë™ í• ë‹¹: ${auto.autoAssignment ? 'âœ…' : 'âŒ'}`)
        console.log(`  â€¢ ìë™ ì§„í–‰ ì¶”ì : ${auto.autoProgressTracking ? 'âœ…' : 'âŒ'}`)
        console.log(`  â€¢ ìë™í™” ì ìˆ˜: ${auto.automationScore}/100 (${auto.level})`)

        // ê°œì„  ë°©ì•ˆ
        console.log('\nğŸ’¡ ê°œì„  ë°©ì•ˆ:')
        this.analysisResults.improvements.forEach((improvement, index) => {
            const priority = improvement.priority === 'high' ? 'ğŸš¨' :
                improvement.priority === 'medium' ? 'âš ï¸' : 'ğŸ“'
            console.log(`  ${index + 1}. ${priority} ${improvement.title}`)
            console.log(`     ${improvement.description}`)
            console.log(`     â†’ ${improvement.action}`)
        })

        // ì „ì²´ íš¨ìœ¨ì„± ì ìˆ˜
        const overallScore = Math.round((
            bug.efficiency +
            todo.efficiency +
            auto.automationScore
        ) / 3)

        console.log('\n' + '='.repeat(60))
        console.log(`ğŸ¯ ì „ì²´ íš¨ìœ¨ì„± ì ìˆ˜: ${overallScore}/100`)

        if (overallScore >= 80) {
            console.log('ğŸ† ìš°ìˆ˜í•œ íš¨ìœ¨ì„±! ì‹œìŠ¤í…œì´ ì˜ ì‘ë™í•˜ê³  ìˆìŠµë‹ˆë‹¤.')
        } else if (overallScore >= 60) {
            console.log('ğŸ‘ ì–‘í˜¸í•œ íš¨ìœ¨ì„±. ëª‡ ê°€ì§€ ê°œì„ ì´ í•„ìš”í•©ë‹ˆë‹¤.')
        } else if (overallScore >= 40) {
            console.log('âš ï¸ ë³´í†µ íš¨ìœ¨ì„±. ìƒë‹¹í•œ ê°œì„ ì´ í•„ìš”í•©ë‹ˆë‹¤.')
        } else {
            console.log('ğŸš¨ ë‚®ì€ íš¨ìœ¨ì„±. ì¦‰ì‹œ ê°œì„ ì´ í•„ìš”í•©ë‹ˆë‹¤.')
        }

        console.log('='.repeat(60))
    }
}

// ì‹¤í–‰
if (require.main === module) {
    const analyzer = new EfficiencyAnalyzer()
    analyzer.analyze()
        .then(() => {
            console.log('\nâœ… íš¨ìœ¨ì„± ë¶„ì„ ì™„ë£Œ')
            process.exit(0)
        })
        .catch(error => {
            console.error('âŒ ì‹¤í–‰ ì˜¤ë¥˜:', error.message)
            process.exit(1)
        })
}

module.exports = EfficiencyAnalyzer
