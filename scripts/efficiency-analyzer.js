#!/usr/bin/env node

/**
 * 효율성 분석기
 * 
 * 이 스크립트는 다음을 분석합니다:
 * 1. 현재 시스템의 버그 감지 효율성
 * 2. TODO 생성 정확도
 * 3. 자동화 수준
 * 4. 개선 필요 영역
 */

const fs = require('fs').promises
const path = require('path')

class EfficiencyAnalyzer {
    constructor() {
        this.analysisResults = {
            bugDetection: {},
            todoGeneration: {},
            automation: {},
            improvements: {}
        }
    }

    async analyze() {
        console.log('📊 시스템 효율성 분석 시작...')

        try {
            // 1. 버그 감지 효율성 분석
            await this.analyzeBugDetection()

            // 2. TODO 생성 효율성 분석
            await this.analyzeTodoGeneration()

            // 3. 자동화 수준 분석
            await this.analyzeAutomation()

            // 4. 개선 방안 제시
            await this.generateImprovements()

            // 5. 결과 출력
            this.displayResults()

        } catch (error) {
            console.error('❌ 분석 오류:', error.message)
        }
    }

    async analyzeBugDetection() {
        console.log('🐛 버그 감지 효율성 분석...')

        const bugStats = {
            totalDetected: 0,
            criticalBugs: 0,
            highBugs: 0,
            mediumBugs: 0,
            lowBugs: 0,
            falsePositives: 0,
            missedBugs: 0
        }

        // TODO 파일에서 버그 통계 수집
        try {
            const content = await fs.readFile('docs/todo-backlog.md', 'utf8')
            const lines = content.split('\n')

            for (const line of lines) {
                if (line.includes('🐛') && line.includes('|')) {
                    bugStats.totalDetected++

                    if (line.includes('critical')) bugStats.criticalBugs++
                    else if (line.includes('high')) bugStats.highBugs++
                    else if (line.includes('medium')) bugStats.mediumBugs++
                    else if (line.includes('low')) bugStats.lowBugs++
                }
            }
        } catch (error) {
            console.warn('⚠️ TODO 파일 분석 실패:', error.message)
        }

        // 로그 파일에서 실제 에러 확인
        const logFiles = ['logs/runtime.log', 'logs/auto-progress.log']
        let actualErrors = 0

        for (const logFile of logFiles) {
            try {
                const content = await fs.readFile(logFile, 'utf8')
                const errorLines = content.split('\n').filter(line =>
                    line.includes('ERROR') ||
                    line.includes('WARN') ||
                    line.includes('Exception') ||
                    line.includes('Failed')
                )
                actualErrors += errorLines.length
            } catch (err) {
                // 파일이 없으면 무시
            }
        }

        // 효율성 계산
        const detectionRate = actualErrors > 0 ? (bugStats.totalDetected / actualErrors) * 100 : 0
        const criticalDetectionRate = bugStats.criticalBugs > 0 ? (bugStats.criticalBugs / bugStats.totalDetected) * 100 : 0

        this.analysisResults.bugDetection = {
            ...bugStats,
            actualErrors,
            detectionRate: Math.round(detectionRate),
            criticalDetectionRate: Math.round(criticalDetectionRate),
            efficiency: this.calculateEfficiency(detectionRate, criticalDetectionRate)
        }
    }

    async analyzeTodoGeneration() {
        console.log('📝 TODO 생성 효율성 분석...')

        const todoStats = {
            totalGenerated: 0,
            autoGenerated: 0,
            manualCreated: 0,
            completed: 0,
            inProgress: 0,
            pending: 0,
            duplicates: 0
        }

        try {
            const content = await fs.readFile('docs/todo-backlog.md', 'utf8')
            const lines = content.split('\n')

            for (const line of lines) {
                if (line.includes('|') && (line.includes('⬜') || line.includes('🟨') || line.includes('✅'))) {
                    todoStats.totalGenerated++

                    if (line.includes('🤖')) todoStats.autoGenerated++
                    else todoStats.manualCreated++

                    if (line.includes('✅')) todoStats.completed++
                    else if (line.includes('🟨')) todoStats.inProgress++
                    else if (line.includes('⬜')) todoStats.pending++
                }
            }

            // 중복 TODO 감지 (간단한 제목 비교)
            const titles = lines
                .filter(line => line.includes('|') && line.includes('⬜'))
                .map(line => line.split('|')[1]?.trim())
                .filter(title => title)

            const uniqueTitles = new Set(titles)
            todoStats.duplicates = titles.length - uniqueTitles.size

        } catch (error) {
            console.warn('⚠️ TODO 분석 실패:', error.message)
        }

        // 효율성 계산
        const completionRate = todoStats.totalGenerated > 0 ? (todoStats.completed / todoStats.totalGenerated) * 100 : 0
        const autoGenerationRate = todoStats.totalGenerated > 0 ? (todoStats.autoGenerated / todoStats.totalGenerated) * 100 : 0
        const duplicateRate = todoStats.totalGenerated > 0 ? (todoStats.duplicates / todoStats.totalGenerated) * 100 : 0

        this.analysisResults.todoGeneration = {
            ...todoStats,
            completionRate: Math.round(completionRate),
            autoGenerationRate: Math.round(autoGenerationRate),
            duplicateRate: Math.round(duplicateRate),
            efficiency: this.calculateTodoEfficiency(completionRate, autoGenerationRate, duplicateRate)
        }
    }

    async analyzeAutomation() {
        console.log('🤖 자동화 수준 분석...')

        const automationStats = {
            scriptsAvailable: 0,
            scriptsWorking: 0,
            scheduledTasks: 0,
            realTimeMonitoring: false,
            autoAssignment: false,
            autoProgressTracking: false
        }

        // 스크립트 파일 확인
        const scriptFiles = [
            'scripts/auto-todo-generator.js',
            'scripts/auto-task-assigner.js',
            'scripts/auto-progress-tracker.js',
            'scripts/manager-centric-system.js',
            'scripts/ai-escalation-system.js',
            'scripts/ai-integration.js'
        ]

        for (const script of scriptFiles) {
            try {
                await fs.access(script)
                automationStats.scriptsAvailable++

                // 스크립트가 실행 가능한지 확인 (간단한 문법 체크)
                const content = await fs.readFile(script, 'utf8')
                if (content.includes('class ') && content.includes('async ')) {
                    automationStats.scriptsWorking++
                }
            } catch (err) {
                // 파일이 없거나 읽을 수 없음
            }
        }

        // GitHub Actions 확인
        try {
            await fs.access('.github/workflows/auto-development.yml')
            automationStats.scheduledTasks++
        } catch (err) {
            // 파일이 없음
        }

        // 실시간 모니터링 확인
        try {
            const content = await fs.readFile('scripts/manager-centric-system.js', 'utf8')
            if (content.includes('--mode=monitor')) {
                automationStats.realTimeMonitoring = true
            }
        } catch (err) {
            // 파일이 없음
        }

        // 자동 할당 확인
        try {
            const content = await fs.readFile('scripts/auto-task-assigner.js', 'utf8')
            if (content.includes('assignTasks')) {
                automationStats.autoAssignment = true
            }
        } catch (err) {
            // 파일이 없음
        }

        // 자동 진행 추적 확인
        try {
            const content = await fs.readFile('scripts/auto-progress-tracker.js', 'utf8')
            if (content.includes('analyzeProgress')) {
                automationStats.autoProgressTracking = true
            }
        } catch (err) {
            // 파일이 없음
        }

        // 자동화 수준 계산
        const automationScore = this.calculateAutomationScore(automationStats)

        this.analysisResults.automation = {
            ...automationStats,
            automationScore,
            level: this.getAutomationLevel(automationScore)
        }
    }

    async generateImprovements() {
        console.log('💡 개선 방안 생성...')

        const improvements = []

        // 버그 감지 개선
        if (this.analysisResults.bugDetection.detectionRate < 70) {
            improvements.push({
                category: 'bug_detection',
                priority: 'high',
                title: '버그 감지율 향상',
                description: `현재 감지율 ${this.analysisResults.bugDetection.detectionRate}%를 90% 이상으로 향상`,
                action: '로그 패턴 분석 강화, 새로운 에러 타입 감지 로직 추가'
            })
        }

        // TODO 생성 개선
        if (this.analysisResults.todoGeneration.duplicateRate > 10) {
            improvements.push({
                category: 'todo_generation',
                priority: 'medium',
                title: '중복 TODO 제거',
                description: `현재 중복률 ${this.analysisResults.todoGeneration.duplicateRate}%를 5% 이하로 감소`,
                action: '중복 감지 알고리즘 개선, TODO 정규화 로직 추가'
            })
        }

        // 자동화 개선
        if (this.analysisResults.automation.automationScore < 70) {
            improvements.push({
                category: 'automation',
                priority: 'high',
                title: '자동화 수준 향상',
                description: `현재 자동화 점수 ${this.analysisResults.automation.automationScore}%를 90% 이상으로 향상`,
                action: '스크립트 안정성 개선, 스케줄링 최적화, 모니터링 강화'
            })
        }

        // 성능 개선
        improvements.push({
            category: 'performance',
            priority: 'medium',
            title: '시스템 성능 최적화',
            description: '처리 속도 및 리소스 사용량 최적화',
            action: '캐싱 도입, 병렬 처리 개선, 메모리 사용량 최적화'
        })

        this.analysisResults.improvements = improvements
    }

    calculateEfficiency(detectionRate, criticalDetectionRate) {
        // 버그 감지 효율성 계산 (0-100)
        const baseScore = Math.min(detectionRate, 100)
        const criticalBonus = criticalDetectionRate * 0.2
        return Math.min(Math.round(baseScore + criticalBonus), 100)
    }

    calculateTodoEfficiency(completionRate, autoGenerationRate, duplicateRate) {
        // TODO 효율성 계산 (0-100)
        const baseScore = (completionRate + autoGenerationRate) / 2
        const duplicatePenalty = duplicateRate * 0.5
        return Math.max(Math.round(baseScore - duplicatePenalty), 0)
    }

    calculateAutomationScore(stats) {
        let score = 0

        // 스크립트 가용성 (30점)
        score += (stats.scriptsWorking / stats.scriptsAvailable) * 30

        // 스케줄링 (20점)
        score += stats.scheduledTasks * 20

        // 실시간 모니터링 (20점)
        score += stats.realTimeMonitoring ? 20 : 0

        // 자동 할당 (15점)
        score += stats.autoAssignment ? 15 : 0

        // 자동 진행 추적 (15점)
        score += stats.autoProgressTracking ? 15 : 0

        return Math.round(score)
    }

    getAutomationLevel(score) {
        if (score >= 90) return 'Expert'
        if (score >= 70) return 'Advanced'
        if (score >= 50) return 'Intermediate'
        if (score >= 30) return 'Basic'
        return 'Beginner'
    }

    displayResults() {
        console.log('\n' + '='.repeat(60))
        console.log('📊 시스템 효율성 분석 결과')
        console.log('='.repeat(60))

        // 버그 감지 효율성
        const bug = this.analysisResults.bugDetection
        console.log('\n🐛 버그 감지 효율성:')
        console.log(`  • 총 감지된 버그: ${bug.totalDetected}개`)
        console.log(`  • 실제 에러: ${bug.actualErrors}개`)
        console.log(`  • 감지율: ${bug.detectionRate}%`)
        console.log(`  • 효율성 점수: ${bug.efficiency}/100`)

        // TODO 생성 효율성
        const todo = this.analysisResults.todoGeneration
        console.log('\n📝 TODO 생성 효율성:')
        console.log(`  • 총 생성된 TODO: ${todo.totalGenerated}개`)
        console.log(`  • 자동 생성: ${todo.autoGenerated}개 (${todo.autoGenerationRate}%)`)
        console.log(`  • 완료율: ${todo.completionRate}%`)
        console.log(`  • 중복률: ${todo.duplicateRate}%`)
        console.log(`  • 효율성 점수: ${todo.efficiency}/100`)

        // 자동화 수준
        const auto = this.analysisResults.automation
        console.log('\n🤖 자동화 수준:')
        console.log(`  • 사용 가능한 스크립트: ${auto.scriptsAvailable}개`)
        console.log(`  • 작동하는 스크립트: ${auto.scriptsWorking}개`)
        console.log(`  • 스케줄된 작업: ${auto.scheduledTasks}개`)
        console.log(`  • 실시간 모니터링: ${auto.realTimeMonitoring ? '✅' : '❌'}`)
        console.log(`  • 자동 할당: ${auto.autoAssignment ? '✅' : '❌'}`)
        console.log(`  • 자동 진행 추적: ${auto.autoProgressTracking ? '✅' : '❌'}`)
        console.log(`  • 자동화 점수: ${auto.automationScore}/100 (${auto.level})`)

        // 개선 방안
        console.log('\n💡 개선 방안:')
        this.analysisResults.improvements.forEach((improvement, index) => {
            const priority = improvement.priority === 'high' ? '🚨' :
                improvement.priority === 'medium' ? '⚠️' : '📝'
            console.log(`  ${index + 1}. ${priority} ${improvement.title}`)
            console.log(`     ${improvement.description}`)
            console.log(`     → ${improvement.action}`)
        })

        // 전체 효율성 점수
        const overallScore = Math.round((
            bug.efficiency +
            todo.efficiency +
            auto.automationScore
        ) / 3)

        console.log('\n' + '='.repeat(60))
        console.log(`🎯 전체 효율성 점수: ${overallScore}/100`)

        if (overallScore >= 80) {
            console.log('🏆 우수한 효율성! 시스템이 잘 작동하고 있습니다.')
        } else if (overallScore >= 60) {
            console.log('👍 양호한 효율성. 몇 가지 개선이 필요합니다.')
        } else if (overallScore >= 40) {
            console.log('⚠️ 보통 효율성. 상당한 개선이 필요합니다.')
        } else {
            console.log('🚨 낮은 효율성. 즉시 개선이 필요합니다.')
        }

        console.log('='.repeat(60))
    }
}

// 실행
if (require.main === module) {
    const analyzer = new EfficiencyAnalyzer()
    analyzer.analyze()
        .then(() => {
            console.log('\n✅ 효율성 분석 완료')
            process.exit(0)
        })
        .catch(error => {
            console.error('❌ 실행 오류:', error.message)
            process.exit(1)
        })
}

module.exports = EfficiencyAnalyzer
