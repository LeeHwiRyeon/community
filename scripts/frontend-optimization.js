#!/usr/bin/env node

/**
 * üöÄ ÌîÑÎ°†Ìä∏ÏóîÎìú ÏÑ±Îä• ÏµúÏ†ÅÌôî Ïä§ÌÅ¨Î¶ΩÌä∏
 * 
 * Ïù¥ Ïä§ÌÅ¨Î¶ΩÌä∏Îäî Îã§Ïùå ÏûëÏóÖÏùÑ ÏàòÌñâÌï©ÎãàÎã§:
 * 1. Î≤àÎì§ ÌÅ¨Í∏∞ Î∂ÑÏÑù Î∞è ÏµúÏ†ÅÌôî
 * 2. Ïù¥ÎØ∏ÏßÄ ÏµúÏ†ÅÌôî
 * 3. ÏΩîÎìú Ïä§ÌîåÎ¶¨ÌåÖ Î∂ÑÏÑù
 * 4. Î©îÎ™®Î¶¨ ÏÇ¨Ïö©Îüâ ÏµúÏ†ÅÌôî
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');
const { performance } = require('perf_hooks');

// ÏÉâÏÉÅ Ï†ïÏùò
const colors = {
    reset: '\x1b[0m',
    bright: '\x1b[1m',
    red: '\x1b[31m',
    green: '\x1b[32m',
    yellow: '\x1b[33m',
    blue: '\x1b[34m',
    magenta: '\x1b[35m',
    cyan: '\x1b[36m'
};

const log = (message, color = 'reset') => {
    console.log(`${colors[color]}${message}${colors.reset}`);
};

// ÌîÑÎ°†Ìä∏ÏóîÎìú ÎîîÎ†âÌÜ†Î¶¨ Í≤ΩÎ°ú
const frontendDir = path.join(__dirname, '../frontend');
const srcDir = path.join(frontendDir, 'src');
const buildDir = path.join(frontendDir, 'dist');
const publicDir = path.join(frontendDir, 'public');

class FrontendOptimizer {
    constructor() {
        this.results = {
            bundleAnalysis: {},
            imageOptimization: {},
            codeSplitting: {},
            memoryUsage: {},
            recommendations: []
        };
    }

    // Î≤àÎì§ ÌÅ¨Í∏∞ Î∂ÑÏÑù
    analyzeBundleSize() {
        log('\nüì¶ Î≤àÎì§ ÌÅ¨Í∏∞ Î∂ÑÏÑù Ï§ë...', 'cyan');

        const analysis = {
            totalFiles: 0,
            totalSize: 0,
            fileTypes: {},
            largestFiles: [],
            duplicateDependencies: [],
            unusedDependencies: []
        };

        if (!fs.existsSync(buildDir)) {
            log('‚ö†Ô∏è  ÎπåÎìú ÎîîÎ†âÌÜ†Î¶¨Í∞Ä ÏóÜÏäµÎãàÎã§. Î®ºÏ†Ä ÎπåÎìúÎ•º Ïã§ÌñâÌïòÏÑ∏Ïöî.', 'yellow');
            return analysis;
        }

        // ÎπåÎìú ÌååÏùº Î∂ÑÏÑù
        this.analyzeDirectory(buildDir, analysis);

        // package.json ÏùòÏ°¥ÏÑ± Î∂ÑÏÑù
        this.analyzeDependencies(frontendDir, analysis);

        log(`  üìÅ Ï¥ù ÌååÏùº Ïàò: ${analysis.totalFiles}Í∞ú`, 'blue');
        log(`  üíæ Ï¥ù ÌÅ¨Í∏∞: ${(analysis.totalSize / 1024 / 1024).toFixed(2)}MB`, 'blue');

        // ÌååÏùº ÌÉÄÏûÖÎ≥Ñ Î∂ÑÌè¨
        log('  üìä ÌååÏùº ÌÉÄÏûÖÎ≥Ñ Î∂ÑÌè¨:', 'blue');
        Object.entries(analysis.fileTypes).forEach(([type, count]) => {
            log(`    ${type}: ${count}Í∞ú`, 'blue');
        });

        // Í∞ÄÏû• ÌÅ∞ ÌååÏùºÎì§
        if (analysis.largestFiles.length > 0) {
            log('  üìÑ Í∞ÄÏû• ÌÅ∞ ÌååÏùºÎì§:', 'blue');
            analysis.largestFiles.slice(0, 5).forEach((file, index) => {
                log(`    ${index + 1}. ${file.name} (${(file.size / 1024).toFixed(1)}KB)`, 'blue');
            });
        }

        this.results.bundleAnalysis = analysis;
        return analysis;
    }

    analyzeDirectory(dir, analysis) {
        const files = fs.readdirSync(dir);

        for (const file of files) {
            const filePath = path.join(dir, file);
            const stats = fs.statSync(filePath);

            if (stats.isDirectory()) {
                this.analyzeDirectory(filePath, analysis);
            } else {
                analysis.totalFiles++;
                analysis.totalSize += stats.size;

                const ext = path.extname(file);
                analysis.fileTypes[ext] = (analysis.fileTypes[ext] || 0) + 1;

                analysis.largestFiles.push({
                    name: path.relative(buildDir, filePath),
                    size: stats.size
                });
            }
        }

        // ÌÅ¨Í∏∞ÏàúÏúºÎ°ú Ï†ïÎ†¨
        analysis.largestFiles.sort((a, b) => b.size - a.size);
    }

    analyzeDependencies(projectDir, analysis) {
        const packageJsonPath = path.join(projectDir, 'package.json');

        if (!fs.existsSync(packageJsonPath)) {
            return;
        }

        const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
        const dependencies = Object.keys(packageJson.dependencies || {});
        const devDependencies = Object.keys(packageJson.devDependencies || {});

        analysis.dependencies = {
            production: dependencies.length,
            development: devDependencies.length,
            total: dependencies.length + devDependencies.length
        };

        log(`  üì¶ ÏùòÏ°¥ÏÑ±: ÌîÑÎ°úÎçïÏÖò ${dependencies.length}Í∞ú, Í∞úÎ∞ú ${devDependencies.length}Í∞ú`, 'blue');
    }

    // Ïù¥ÎØ∏ÏßÄ ÏµúÏ†ÅÌôî Î∂ÑÏÑù
    analyzeImages() {
        log('\nüñºÔ∏è  Ïù¥ÎØ∏ÏßÄ ÏµúÏ†ÅÌôî Î∂ÑÏÑù Ï§ë...', 'cyan');

        const analysis = {
            totalImages: 0,
            totalSize: 0,
            imageTypes: {},
            unoptimizedImages: [],
            recommendations: []
        };

        // src ÎîîÎ†âÌÜ†Î¶¨ÏóêÏÑú Ïù¥ÎØ∏ÏßÄ ÌååÏùº Ï∞æÍ∏∞
        this.findImages(srcDir, analysis);

        // public ÎîîÎ†âÌÜ†Î¶¨ÏóêÏÑú Ïù¥ÎØ∏ÏßÄ ÌååÏùº Ï∞æÍ∏∞
        if (fs.existsSync(publicDir)) {
            this.findImages(publicDir, analysis);
        }

        log(`  üñºÔ∏è  Ï¥ù Ïù¥ÎØ∏ÏßÄ Ïàò: ${analysis.totalImages}Í∞ú`, 'blue');
        log(`  üíæ Ï¥ù ÌÅ¨Í∏∞: ${(analysis.totalSize / 1024 / 1024).toFixed(2)}MB`, 'blue');

        // Ïù¥ÎØ∏ÏßÄ ÌÉÄÏûÖÎ≥Ñ Î∂ÑÌè¨
        log('  üìä Ïù¥ÎØ∏ÏßÄ ÌÉÄÏûÖÎ≥Ñ Î∂ÑÌè¨:', 'blue');
        Object.entries(analysis.imageTypes).forEach(([type, count]) => {
            log(`    ${type}: ${count}Í∞ú`, 'blue');
        });

        // ÏµúÏ†ÅÌôî Í∂åÏû•ÏÇ¨Ìï≠
        if (analysis.totalSize > 5 * 1024 * 1024) { // 5MB Ïù¥ÏÉÅ
            analysis.recommendations.push('Ïù¥ÎØ∏ÏßÄ ÌÅ¨Í∏∞Í∞Ä 5MBÎ•º Ï¥àÍ≥ºÌï©ÎãàÎã§. WebP Î≥ÄÌôòÏùÑ Í∂åÏû•Ìï©ÎãàÎã§.');
        }

        if (analysis.imageTypes['.png'] > analysis.imageTypes['.jpg']) {
            analysis.recommendations.push('PNG ÌååÏùºÏù¥ ÎßéÏäµÎãàÎã§. JPGÎ°ú Î≥ÄÌôòÏùÑ Í≥†Î†§ÌïòÏÑ∏Ïöî.');
        }

        if (analysis.unoptimizedImages.length > 0) {
            analysis.recommendations.push(`${analysis.unoptimizedImages.length}Í∞úÏùò Ïù¥ÎØ∏ÏßÄÍ∞Ä ÏµúÏ†ÅÌôîÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.`);
        }

        this.results.imageOptimization = analysis;
        return analysis;
    }

    findImages(dir, analysis) {
        if (!fs.existsSync(dir)) return;

        const files = fs.readdirSync(dir);

        for (const file of files) {
            const filePath = path.join(dir, file);
            const stats = fs.statSync(filePath);

            if (stats.isDirectory()) {
                this.findImages(filePath, analysis);
            } else {
                const ext = path.extname(file).toLowerCase();
                if (['.jpg', '.jpeg', '.png', '.gif', '.webp', '.svg'].includes(ext)) {
                    analysis.totalImages++;
                    analysis.totalSize += stats.size;

                    analysis.imageTypes[ext] = (analysis.imageTypes[ext] || 0) + 1;

                    // ÏµúÏ†ÅÌôîÎêòÏßÄ ÏïäÏùÄ Ïù¥ÎØ∏ÏßÄ Ï≤¥ÌÅ¨
                    if (stats.size > 500 * 1024) { // 500KB Ïù¥ÏÉÅ
                        analysis.unoptimizedImages.push({
                            path: path.relative(frontendDir, filePath),
                            size: stats.size
                        });
                    }
                }
            }
        }
    }

    // ÏΩîÎìú Ïä§ÌîåÎ¶¨ÌåÖ Î∂ÑÏÑù
    analyzeCodeSplitting() {
        log('\nüîÄ ÏΩîÎìú Ïä§ÌîåÎ¶¨ÌåÖ Î∂ÑÏÑù Ï§ë...', 'cyan');

        const analysis = {
            hasCodeSplitting: false,
            chunkFiles: [],
            lazyLoadedComponents: [],
            recommendations: []
        };

        // React.lazy ÏÇ¨Ïö© Ïó¨Î∂Ä ÌôïÏù∏
        const lazyComponents = this.findLazyComponents(srcDir);
        analysis.lazyLoadedComponents = lazyComponents;

        if (lazyComponents.length > 0) {
            analysis.hasCodeSplitting = true;
            log(`  ‚úÖ ÏßÄÏó∞ Î°úÎî© Ïª¥Ìè¨ÎÑåÌä∏: ${lazyComponents.length}Í∞ú`, 'green');
        } else {
            log('  ‚ö†Ô∏è  ÏßÄÏó∞ Î°úÎî©Ïù¥ Íµ¨ÌòÑÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.', 'yellow');
            analysis.recommendations.push('React.lazy()Î•º ÏÇ¨Ïö©Ìïú ÏΩîÎìú Ïä§ÌîåÎ¶¨ÌåÖÏùÑ Íµ¨ÌòÑÌïòÏÑ∏Ïöî.');
        }

        // ÎπåÎìúÎêú Ï≤≠ÌÅ¨ ÌååÏùº ÌôïÏù∏
        if (fs.existsSync(buildDir)) {
            const chunkFiles = this.findChunkFiles(buildDir);
            analysis.chunkFiles = chunkFiles;

            if (chunkFiles.length > 1) {
                log(`  üì¶ Ï≤≠ÌÅ¨ ÌååÏùº: ${chunkFiles.length}Í∞ú`, 'blue');
                chunkFiles.forEach(chunk => {
                    log(`    - ${chunk.name} (${(chunk.size / 1024).toFixed(1)}KB)`, 'blue');
                });
            }
        }

        this.results.codeSplitting = analysis;
        return analysis;
    }

    findLazyComponents(dir) {
        const lazyComponents = [];

        if (!fs.existsSync(dir)) return lazyComponents;

        const files = fs.readdirSync(dir);

        for (const file of files) {
            const filePath = path.join(dir, file);
            const stats = fs.statSync(filePath);

            if (stats.isDirectory()) {
                lazyComponents.push(...this.findLazyComponents(filePath));
            } else if (file.endsWith('.tsx') || file.endsWith('.ts') || file.endsWith('.jsx') || file.endsWith('.js')) {
                const content = fs.readFileSync(filePath, 'utf8');

                // React.lazy ÏÇ¨Ïö© Ïó¨Î∂Ä ÌôïÏù∏
                if (content.includes('React.lazy') || content.includes('lazy(')) {
                    lazyComponents.push({
                        file: path.relative(frontendDir, filePath),
                        hasLazy: true
                    });
                }
            }
        }

        return lazyComponents;
    }

    findChunkFiles(dir) {
        const chunkFiles = [];

        if (!fs.existsSync(dir)) return chunkFiles;

        const files = fs.readdirSync(dir);

        for (const file of files) {
            const filePath = path.join(dir, file);
            const stats = fs.statSync(filePath);

            if (stats.isDirectory()) {
                chunkFiles.push(...this.findChunkFiles(filePath));
            } else if (file.includes('chunk') || file.endsWith('.js')) {
                chunkFiles.push({
                    name: path.relative(buildDir, filePath),
                    size: stats.size
                });
            }
        }

        return chunkFiles.sort((a, b) => b.size - a.size);
    }

    // Î©îÎ™®Î¶¨ ÏÇ¨Ïö©Îüâ Î∂ÑÏÑù
    analyzeMemoryUsage() {
        log('\nüíæ Î©îÎ™®Î¶¨ ÏÇ¨Ïö©Îüâ Î∂ÑÏÑù Ï§ë...', 'cyan');

        const memUsage = process.memoryUsage();
        const analysis = {
            rss: Math.round(memUsage.rss / 1024 / 1024), // MB
            heapTotal: Math.round(memUsage.heapTotal / 1024 / 1024), // MB
            heapUsed: Math.round(memUsage.heapUsed / 1024 / 1024), // MB
            external: Math.round(memUsage.external / 1024 / 1024), // MB
            recommendations: []
        };

        log(`  RSS: ${analysis.rss}MB`, 'blue');
        log(`  Heap Total: ${analysis.heapTotal}MB`, 'blue');
        log(`  Heap Used: ${analysis.heapUsed}MB`, 'blue');
        log(`  External: ${analysis.external}MB`, 'blue');

        // Î©îÎ™®Î¶¨ ÏÇ¨Ïö©Îüâ Í∂åÏû•ÏÇ¨Ìï≠
        if (analysis.heapUsed > 100) {
            analysis.recommendations.push('Ìûô Î©îÎ™®Î¶¨ ÏÇ¨Ïö©ÎüâÏù¥ ÎÜíÏäµÎãàÎã§. Î©îÎ™®Î¶¨ ÎàÑÏàò Í≤ÄÏÇ¨Î•º Í∂åÏû•Ìï©ÎãàÎã§.');
        }

        if (analysis.external > 50) {
            analysis.recommendations.push('Ïô∏Î∂Ä Î©îÎ™®Î¶¨ ÏÇ¨Ïö©ÎüâÏù¥ ÎÜíÏäµÎãàÎã§. C++ Î∞îÏù∏Îî© ÏÇ¨Ïö©ÏùÑ Í≤ÄÌÜ†ÌïòÏÑ∏Ïöî.');
        }

        this.results.memoryUsage = analysis;
        return analysis;
    }

    // ÏµúÏ†ÅÌôî Í∂åÏû•ÏÇ¨Ìï≠ ÏÉùÏÑ±
    generateRecommendations() {
        const recommendations = [];

        // Î≤àÎì§ ÌÅ¨Í∏∞ Í∂åÏû•ÏÇ¨Ìï≠
        if (this.results.bundleAnalysis.totalSize > 10 * 1024 * 1024) { // 10MB Ïù¥ÏÉÅ
            recommendations.push('Î≤àÎì§ ÌÅ¨Í∏∞Í∞Ä 10MBÎ•º Ï¥àÍ≥ºÌï©ÎãàÎã§. ÏΩîÎìú Ïä§ÌîåÎ¶¨ÌåÖÏùÑ Íµ¨ÌòÑÌïòÏÑ∏Ïöî.');
        }

        // Ïù¥ÎØ∏ÏßÄ ÏµúÏ†ÅÌôî Í∂åÏû•ÏÇ¨Ìï≠
        if (this.results.imageOptimization.totalSize > 5 * 1024 * 1024) { // 5MB Ïù¥ÏÉÅ
            recommendations.push('Ïù¥ÎØ∏ÏßÄ ÌÅ¨Í∏∞Í∞Ä 5MBÎ•º Ï¥àÍ≥ºÌï©ÎãàÎã§. WebP Î≥ÄÌôò Î∞è ÏïïÏ∂ïÏùÑ Í∂åÏû•Ìï©ÎãàÎã§.');
        }

        // ÏΩîÎìú Ïä§ÌîåÎ¶¨ÌåÖ Í∂åÏû•ÏÇ¨Ìï≠
        if (!this.results.codeSplitting.hasCodeSplitting) {
            recommendations.push('ÏΩîÎìú Ïä§ÌîåÎ¶¨ÌåÖÏù¥ Íµ¨ÌòÑÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§. React.lazy()Î•º ÏÇ¨Ïö©ÌïòÏÑ∏Ïöî.');
        }

        // Î©îÎ™®Î¶¨ ÏÇ¨Ïö©Îüâ Í∂åÏû•ÏÇ¨Ìï≠
        if (this.results.memoryUsage.heapUsed > 100) {
            recommendations.push('Î©îÎ™®Î¶¨ ÏÇ¨Ïö©ÎüâÏù¥ ÎÜíÏäµÎãàÎã§. Ïª¥Ìè¨ÎÑåÌä∏ ÏµúÏ†ÅÌôîÎ•º Í∂åÏû•Ìï©ÎãàÎã§.');
        }

        // ÏùºÎ∞òÏ†ÅÏù∏ Í∂åÏû•ÏÇ¨Ìï≠
        recommendations.push('Ï†ïÍ∏∞Ï†ÅÏù∏ Î≤àÎì§ Î∂ÑÏÑùÏùÑ ÏúÑÌï¥ webpack-bundle-analyzerÎ•º ÏÇ¨Ïö©ÌïòÏÑ∏Ïöî.');
        recommendations.push('Ïù¥ÎØ∏ÏßÄ ÏµúÏ†ÅÌôîÎ•º ÏúÑÌï¥ next/image ÎòêÎäî react-imageÎ•º ÏÇ¨Ïö©ÌïòÏÑ∏Ïöî.');
        recommendations.push('Î∂àÌïÑÏöîÌïú ÏùòÏ°¥ÏÑ±ÏùÑ Ï†úÍ±∞ÌïòÏó¨ Î≤àÎì§ ÌÅ¨Í∏∞Î•º Ï§ÑÏù¥ÏÑ∏Ïöî.');

        this.results.recommendations = recommendations;
        return recommendations;
    }

    // ÏµúÏ†ÅÌôî Ïä§ÌÅ¨Î¶ΩÌä∏ ÏÉùÏÑ±
    generateOptimizationScripts() {
        log('\nüõ†Ô∏è  ÏµúÏ†ÅÌôî Ïä§ÌÅ¨Î¶ΩÌä∏ ÏÉùÏÑ± Ï§ë...', 'cyan');

        const scripts = {
            webpack: this.generateWebpackConfig(),
            packageJson: this.generatePackageJsonScripts(),
            imageOptimization: this.generateImageOptimizationScript()
        };

        // webpack.config.js ÏÉùÏÑ±
        const webpackConfigPath = path.join(frontendDir, 'webpack.config.optimized.js');
        fs.writeFileSync(webpackConfigPath, scripts.webpack);
        log(`  ‚úÖ Webpack ÏÑ§Ï†ï ÏÉùÏÑ±: ${webpackConfigPath}`, 'green');

        // Ïù¥ÎØ∏ÏßÄ ÏµúÏ†ÅÌôî Ïä§ÌÅ¨Î¶ΩÌä∏ ÏÉùÏÑ±
        const imageScriptPath = path.join(frontendDir, 'scripts', 'optimize-images.js');
        if (!fs.existsSync(path.dirname(imageScriptPath))) {
            fs.mkdirSync(path.dirname(imageScriptPath), { recursive: true });
        }
        fs.writeFileSync(imageScriptPath, scripts.imageOptimization);
        log(`  ‚úÖ Ïù¥ÎØ∏ÏßÄ ÏµúÏ†ÅÌôî Ïä§ÌÅ¨Î¶ΩÌä∏ ÏÉùÏÑ±: ${imageScriptPath}`, 'green');

        return scripts;
    }

    generateWebpackConfig() {
        return `const path = require('path');
const webpack = require('webpack');
const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;

module.exports = {
  mode: 'production',
  entry: './src/index.tsx',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: '[name].[contenthash].js',
    chunkFilename: '[name].[contenthash].chunk.js',
    clean: true,
  },
  optimization: {
    splitChunks: {
      chunks: 'all',
      cacheGroups: {
        vendor: {
          test: /[\\\\/]node_modules[\\\\/]/,
          name: 'vendors',
          chunks: 'all',
        },
        common: {
          name: 'common',
          minChunks: 2,
          chunks: 'all',
          enforce: true,
        },
      },
    },
    usedExports: true,
    sideEffects: false,
  },
  plugins: [
    new webpack.optimize.ModuleConcatenationPlugin(),
    new BundleAnalyzerPlugin({
      analyzerMode: 'static',
      openAnalyzer: false,
    }),
  ],
  resolve: {
    extensions: ['.tsx', '.ts', '.jsx', '.js'],
  },
  module: {
    rules: [
      {
        test: /\\.(ts|tsx)$/,
        use: 'ts-loader',
        exclude: /node_modules/,
      },
      {
        test: /\\.(js|jsx)$/,
        use: 'babel-loader',
        exclude: /node_modules/,
      },
      {
        test: /\\.(png|jpg|jpeg|gif|svg)$/,
        type: 'asset/resource',
        generator: {
          filename: 'images/[name].[contenthash][ext]',
        },
      },
    ],
  },
};`;
    }

    generateImageOptimizationScript() {
        return `const sharp = require('sharp');
const fs = require('fs');
const path = require('path');

async function optimizeImages() {
  const imageDir = path.join(__dirname, '../src/assets/images');
  const outputDir = path.join(__dirname, '../src/assets/images/optimized');
  
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }
  
  const files = fs.readdirSync(imageDir);
  
  for (const file of files) {
    if (/\\.(jpg|jpeg|png)$/i.test(file)) {
      const inputPath = path.join(imageDir, file);
      const outputPath = path.join(outputDir, file.replace(/\\.(jpg|jpeg|png)$/i, '.webp'));
      
      try {
        await sharp(inputPath)
          .webp({ quality: 80 })
          .toFile(outputPath);
        
        console.log(\`Optimized: \${file}\`);
      } catch (error) {
        console.error(\`Error optimizing \${file}:\`, error);
      }
    }
  }
}

optimizeImages();`;
    }

    generatePackageJsonScripts() {
        return {
            "build:analyze": "webpack --config webpack.config.optimized.js",
            "optimize:images": "node scripts/optimize-images.js",
            "bundle:analyze": "npx webpack-bundle-analyzer dist/static/js/*.js"
        };
    }

    // Î≥¥Í≥†ÏÑú ÏÉùÏÑ±
    generateReport() {
        const report = {
            timestamp: new Date().toISOString(),
            bundleAnalysis: this.results.bundleAnalysis,
            imageOptimization: this.results.imageOptimization,
            codeSplitting: this.results.codeSplitting,
            memoryUsage: this.results.memoryUsage,
            recommendations: this.results.recommendations
        };

        const reportsDir = path.join(__dirname, '../reports');
        if (!fs.existsSync(reportsDir)) {
            fs.mkdirSync(reportsDir, { recursive: true });
        }

        const reportPath = path.join(reportsDir, `frontend-optimization-${Date.now()}.json`);
        fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));

        log(`\nüìÑ ÏµúÏ†ÅÌôî Î≥¥Í≥†ÏÑú Ï†ÄÏû•: ${reportPath}`, 'green');
        return reportPath;
    }
}

async function main() {
    log('üöÄ ÌîÑÎ°†Ìä∏ÏóîÎìú ÏÑ±Îä• ÏµúÏ†ÅÌôî Ïä§ÌÅ¨Î¶ΩÌä∏ ÏãúÏûë', 'bright');
    log('=' * 50, 'cyan');

    const optimizer = new FrontendOptimizer();

    try {
        // Î≤àÎì§ ÌÅ¨Í∏∞ Î∂ÑÏÑù
        optimizer.analyzeBundleSize();

        // Ïù¥ÎØ∏ÏßÄ ÏµúÏ†ÅÌôî Î∂ÑÏÑù
        optimizer.analyzeImages();

        // ÏΩîÎìú Ïä§ÌîåÎ¶¨ÌåÖ Î∂ÑÏÑù
        optimizer.analyzeCodeSplitting();

        // Î©îÎ™®Î¶¨ ÏÇ¨Ïö©Îüâ Î∂ÑÏÑù
        optimizer.analyzeMemoryUsage();

        // Í∂åÏû•ÏÇ¨Ìï≠ ÏÉùÏÑ±
        optimizer.generateRecommendations();

        // ÏµúÏ†ÅÌôî Ïä§ÌÅ¨Î¶ΩÌä∏ ÏÉùÏÑ±
        optimizer.generateOptimizationScripts();

        // Î≥¥Í≥†ÏÑú ÏÉùÏÑ±
        optimizer.generateReport();

        // Í≤∞Í≥º Ï∂úÎ†•
        log('\nüìä ÏµúÏ†ÅÌôî Î∂ÑÏÑù Í≤∞Í≥º', 'cyan');
        log('=' * 30, 'cyan');

        if (optimizer.results.recommendations.length > 0) {
            log('\nüí° Í∂åÏû•ÏÇ¨Ìï≠:', 'yellow');
            optimizer.results.recommendations.forEach((rec, index) => {
                log(`  ${index + 1}. ${rec}`, 'yellow');
            });
        } else {
            log('\n‚úÖ Î™®Îì† ÏµúÏ†ÅÌôî Í∏∞Ï§ÄÏùÑ ÎßåÏ°±Ìï©ÎãàÎã§!', 'green');
        }

        log('\nüéâ ÌîÑÎ°†Ìä∏ÏóîÎìú ÏµúÏ†ÅÌôî Î∂ÑÏÑù ÏôÑÎ£å!', 'green');

    } catch (error) {
        log(`\n‚ùå ÏµúÏ†ÅÌôî Î∂ÑÏÑù Ïã§Ìå®: ${error.message}`, 'red');
        process.exit(1);
    }
}

// Ïä§ÌÅ¨Î¶ΩÌä∏ Ïã§Ìñâ
if (require.main === module) {
    main().catch(console.error);
}

module.exports = {
    FrontendOptimizer
};
