#!/usr/bin/env node

/**
 * üîí Ìè¨Í¥ÑÏ†Å Î≥¥Ïïà Í∞êÏÇ¨ Ïä§ÌÅ¨Î¶ΩÌä∏
 * 
 * Ïù¥ Ïä§ÌÅ¨Î¶ΩÌä∏Îäî Îã§Ïùå Î≥¥Ïïà ÏòÅÏó≠ÏùÑ Í≤ÄÏÇ¨Ìï©ÎãàÎã§:
 * 1. ÏùòÏ°¥ÏÑ± Ï∑®ÏïΩÏ†ê Ïä§Ï∫î
 * 2. ÏΩîÎìú Î≥¥Ïïà Î∂ÑÏÑù
 * 3. Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Î≥¥Ïïà Í≤ÄÏÇ¨
 * 4. API Î≥¥Ïïà ÌÖåÏä§Ìä∏
 * 5. Ïù∏ÌîÑÎùº Î≥¥Ïïà Í≤ÄÏÇ¨
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');
const axios = require('axios');

// ÏÉâÏÉÅ Ï†ïÏùò
const colors = {
    reset: '\x1b[0m',
    bright: '\x1b[1m',
    red: '\x1b[31m',
    green: '\x1b[32m',
    yellow: '\x1b[33m',
    blue: '\x1b[34m',
    magenta: '\x1b[35m',
    cyan: '\x1b[36m'
};

const log = (message, color = 'reset') => {
    console.log(`${colors[color]}${message}${colors.reset}`);
};

class SecurityAuditor {
    constructor() {
        this.results = {
            dependencyScan: {},
            codeAnalysis: {},
            databaseSecurity: {},
            apiSecurity: {},
            infrastructureSecurity: {},
            overallScore: 0,
            recommendations: [],
            criticalIssues: [],
            warnings: [],
        };
    }

    // Î©îÏù∏ Í∞êÏÇ¨ Ïã§Ìñâ
    async runAudit() {
        log('üîí Ìè¨Í¥ÑÏ†Å Î≥¥Ïïà Í∞êÏÇ¨ ÏãúÏûë', 'bright');
        log('=' * 50, 'cyan');

        try {
            // 1. ÏùòÏ°¥ÏÑ± Ï∑®ÏïΩÏ†ê Ïä§Ï∫î
            await this.scanDependencies();

            // 2. ÏΩîÎìú Î≥¥Ïïà Î∂ÑÏÑù
            await this.analyzeCodeSecurity();

            // 3. Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Î≥¥Ïïà Í≤ÄÏÇ¨
            await this.checkDatabaseSecurity();

            // 4. API Î≥¥Ïïà ÌÖåÏä§Ìä∏
            await this.testApiSecurity();

            // 5. Ïù∏ÌîÑÎùº Î≥¥Ïïà Í≤ÄÏÇ¨
            await this.checkInfrastructureSecurity();

            // 6. Ï¢ÖÌï© ÌèâÍ∞Ä
            this.evaluateOverallSecurity();

            // 7. Î≥¥Í≥†ÏÑú ÏÉùÏÑ±
            await this.generateReport();

            log('\nüéâ Î≥¥Ïïà Í∞êÏÇ¨ ÏôÑÎ£å!', 'green');

        } catch (error) {
            log(`\n‚ùå Î≥¥Ïïà Í∞êÏÇ¨ Ïã§Ìå®: ${error.message}`, 'red');
            throw error;
        }
    }

    // 1. ÏùòÏ°¥ÏÑ± Ï∑®ÏïΩÏ†ê Ïä§Ï∫î
    async scanDependencies() {
        log('\nüì¶ ÏùòÏ°¥ÏÑ± Ï∑®ÏïΩÏ†ê Ïä§Ï∫î Ï§ë...', 'cyan');

        const scanResults = {
            root: await this.scanPackageJson('.'),
            backend: await this.scanPackageJson('./server-backend'),
            frontend: await this.scanPackageJson('./frontend'),
        };

        this.results.dependencyScan = scanResults;

        // Ï†ÑÏ≤¥ Ï∑®ÏïΩÏ†ê Ïàò Í≥ÑÏÇ∞
        const totalVulnerabilities = Object.values(scanResults)
            .reduce((sum, result) => sum + (result.vulnerabilities?.length || 0), 0);

        if (totalVulnerabilities > 0) {
            this.results.criticalIssues.push(`ÏùòÏ°¥ÏÑ± Ï∑®ÏïΩÏ†ê ${totalVulnerabilities}Í∞ú Î∞úÍ≤¨`);
        }

        log(`  üìä Ï¥ù Ï∑®ÏïΩÏ†ê: ${totalVulnerabilities}Í∞ú`, totalVulnerabilities > 0 ? 'red' : 'green');
    }

    async scanPackageJson(projectPath) {
        try {
            const packageJsonPath = path.join(projectPath, 'package.json');
            if (!fs.existsSync(packageJsonPath)) {
                return { vulnerabilities: [], error: 'package.json not found' };
            }

            // npm audit Ïã§Ìñâ
            const auditResult = execSync('npm audit --json', {
                cwd: projectPath,
                encoding: 'utf8',
                stdio: 'pipe'
            });

            const auditData = JSON.parse(auditResult);

            return {
                vulnerabilities: auditData.vulnerabilities || [],
                summary: auditData.metadata?.vulnerabilities || {},
                error: null,
            };
        } catch (error) {
            return {
                vulnerabilities: [],
                error: error.message,
            };
        }
    }

    // 2. ÏΩîÎìú Î≥¥Ïïà Î∂ÑÏÑù
    async analyzeCodeSecurity() {
        log('\nüîç ÏΩîÎìú Î≥¥Ïïà Î∂ÑÏÑù Ï§ë...', 'cyan');

        const analysisResults = {
            sqlInjection: await this.checkSqlInjection(),
            xssVulnerabilities: await this.checkXssVulnerabilities(),
            authenticationIssues: await this.checkAuthenticationIssues(),
            authorizationIssues: await this.checkAuthorizationIssues(),
            inputValidation: await this.checkInputValidation(),
            secretsExposure: await this.checkSecretsExposure(),
        };

        this.results.codeAnalysis = analysisResults;

        // Î≥¥Ïïà Ïù¥Ïäà Ïàò Í≥ÑÏÇ∞
        const totalIssues = Object.values(analysisResults)
            .reduce((sum, result) => sum + (result.issues?.length || 0), 0);

        if (totalIssues > 0) {
            this.results.warnings.push(`ÏΩîÎìú Î≥¥Ïïà Ïù¥Ïäà ${totalIssues}Í∞ú Î∞úÍ≤¨`);
        }

        log(`  üìä Î≥¥Ïïà Ïù¥Ïäà: ${totalIssues}Í∞ú`, totalIssues > 0 ? 'yellow' : 'green');
    }

    async checkSqlInjection() {
        const patterns = [
            /query\s*\(\s*['"`][^'"`]*\$\{/g,
            /execute\s*\(\s*['"`][^'"`]*\$\{/g,
            /\.query\s*\(\s*[^)]*\+/g,
            /SELECT.*\+.*FROM/g,
            /INSERT.*\+.*INTO/g,
            /UPDATE.*\+.*SET/g,
            /DELETE.*\+.*FROM/g,
        ];

        return await this.scanCodePatterns(patterns, 'SQL Injection');
    }

    async checkXssVulnerabilities() {
        const patterns = [
            /innerHTML\s*=/g,
            /outerHTML\s*=/g,
            /document\.write\s*\(/g,
            /eval\s*\(/g,
            /setTimeout\s*\(\s*['"`]/g,
            /setInterval\s*\(\s*['"`]/g,
        ];

        return await this.scanCodePatterns(patterns, 'XSS');
    }

    async checkAuthenticationIssues() {
        const patterns = [
            /password.*=.*['"`][^'"`]{1,7}['"`]/g, // ÏïΩÌïú ÎπÑÎ∞ÄÎ≤àÌò∏
            /jwt.*secret.*=.*['"`]test/g, // ÌÖåÏä§Ìä∏ ÏãúÌÅ¨Î¶ø
            /jwt.*secret.*=.*['"`]secret/g, // Í∏∞Î≥∏ ÏãúÌÅ¨Î¶ø
            /bcrypt.*rounds.*[0-4]/g, // ÎÇÆÏùÄ bcrypt ÎùºÏö¥Îìú
        ];

        return await this.scanCodePatterns(patterns, 'Authentication');
    }

    async checkAuthorizationIssues() {
        const patterns = [
            /if\s*\(\s*user\s*\)\s*{/g, // Îã®ÏàúÌïú Í∂åÌïú Ï≤¥ÌÅ¨
            /role\s*==\s*['"`]admin['"`]/g, // ÌïòÎìúÏΩîÎî©Îêú Ïó≠Ìï†
            /permission\s*==\s*['"`]write['"`]/g, // ÌïòÎìúÏΩîÎî©Îêú Í∂åÌïú
        ];

        return await this.scanCodePatterns(patterns, 'Authorization');
    }

    async checkInputValidation() {
        const patterns = [
            /req\.body[^.]/g, // ÏßÅÏ†ëÏ†ÅÏù∏ req.body ÏÇ¨Ïö©
            /req\.query[^.]/g, // ÏßÅÏ†ëÏ†ÅÏù∏ req.query ÏÇ¨Ïö©
            /req\.params[^.]/g, // ÏßÅÏ†ëÏ†ÅÏù∏ req.params ÏÇ¨Ïö©
        ];

        return await this.scanCodePatterns(patterns, 'Input Validation');
    }

    async checkSecretsExposure() {
        const patterns = [
            /password\s*:\s*['"`][^'"`]+['"`]/g,
            /secret\s*:\s*['"`][^'"`]+['"`]/g,
            /key\s*:\s*['"`][^'"`]+['"`]/g,
            /token\s*:\s*['"`][^'"`]+['"`]/g,
            /api_key\s*:\s*['"`][^'"`]+['"`]/g,
        ];

        return await this.scanCodePatterns(patterns, 'Secrets Exposure');
    }

    async scanCodePatterns(patterns, issueType) {
        const issues = [];
        const sourceFiles = this.getSourceFiles();

        for (const file of sourceFiles) {
            try {
                const content = fs.readFileSync(file, 'utf8');
                const lines = content.split('\n');

                patterns.forEach(pattern => {
                    let match;
                    while ((match = pattern.exec(content)) !== null) {
                        const lineNumber = content.substring(0, match.index).split('\n').length;
                        issues.push({
                            file: path.relative(process.cwd(), file),
                            line: lineNumber,
                            issue: issueType,
                            code: lines[lineNumber - 1]?.trim(),
                            severity: this.getSeverity(issueType),
                        });
                    }
                });
            } catch (error) {
                // ÌååÏùº ÏùΩÍ∏∞ Ïò§Î•ò Î¨¥Ïãú
            }
        }

        return { issues, count: issues.length };
    }

    getSourceFiles() {
        const extensions = ['.js', '.ts', '.jsx', '.tsx', '.vue'];
        const excludeDirs = ['node_modules', '.git', 'dist', 'build'];

        const files = [];

        const scanDir = (dir) => {
            const items = fs.readdirSync(dir);

            for (const item of items) {
                const fullPath = path.join(dir, item);
                const stat = fs.statSync(fullPath);

                if (stat.isDirectory()) {
                    if (!excludeDirs.includes(item)) {
                        scanDir(fullPath);
                    }
                } else if (extensions.includes(path.extname(item))) {
                    files.push(fullPath);
                }
            }
        };

        scanDir('.');
        return files;
    }

    getSeverity(issueType) {
        const severityMap = {
            'SQL Injection': 'critical',
            'XSS': 'high',
            'Authentication': 'high',
            'Authorization': 'medium',
            'Input Validation': 'medium',
            'Secrets Exposure': 'critical',
        };

        return severityMap[issueType] || 'low';
    }

    // 3. Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Î≥¥Ïïà Í≤ÄÏÇ¨
    async checkDatabaseSecurity() {
        log('\nüóÑÔ∏è  Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Î≥¥Ïïà Í≤ÄÏÇ¨ Ï§ë...', 'cyan');

        const dbSecurity = {
            connectionSecurity: await this.checkDbConnectionSecurity(),
            accessControl: await this.checkDbAccessControl(),
            dataEncryption: await this.checkDataEncryption(),
            backupSecurity: await this.checkBackupSecurity(),
        };

        this.results.databaseSecurity = dbSecurity;

        log(`  üìä Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Î≥¥Ïïà Í≤ÄÏÇ¨ ÏôÑÎ£å`, 'green');
    }

    async checkDbConnectionSecurity() {
        // Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ Î≥¥Ïïà Í≤ÄÏÇ¨
        const issues = [];

        // ÌôòÍ≤Ω Î≥ÄÏàò ÌååÏùº Í≤ÄÏÇ¨
        const envFiles = ['.env', '.env.local', '.env.production'];

        for (const envFile of envFiles) {
            if (fs.existsSync(envFile)) {
                const content = fs.readFileSync(envFile, 'utf8');

                if (content.includes('DB_PASSWORD=password')) {
                    issues.push('Í∏∞Î≥∏ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÎπÑÎ∞ÄÎ≤àÌò∏ ÏÇ¨Ïö©');
                }

                if (content.includes('DB_HOST=localhost')) {
                    issues.push('Î°úÏª¨Ìò∏Ïä§Ìä∏ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏÇ¨Ïö©');
                }

                if (!content.includes('DB_SSL=true')) {
                    issues.push('SSL Ïó∞Í≤∞ ÎØ∏ÏÇ¨Ïö©');
                }
            }
        }

        return { issues, count: issues.length };
    }

    async checkDbAccessControl() {
        // Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï†ëÍ∑º Ï†úÏñ¥ Í≤ÄÏÇ¨
        return { issues: [], count: 0 };
    }

    async checkDataEncryption() {
        // Îç∞Ïù¥ÌÑ∞ ÏïîÌò∏Ìôî Í≤ÄÏÇ¨
        return { issues: [], count: 0 };
    }

    async checkBackupSecurity() {
        // Î∞±ÏóÖ Î≥¥Ïïà Í≤ÄÏÇ¨
        return { issues: [], count: 0 };
    }

    // 4. API Î≥¥Ïïà ÌÖåÏä§Ìä∏
    async testApiSecurity() {
        log('\nüåê API Î≥¥Ïïà ÌÖåÏä§Ìä∏ Ï§ë...', 'cyan');

        const apiTests = {
            authentication: await this.testAuthentication(),
            authorization: await this.testAuthorization(),
            inputValidation: await this.testInputValidation(),
            rateLimiting: await this.testRateLimiting(),
            cors: await this.testCors(),
        };

        this.results.apiSecurity = apiTests;

        log(`  üìä API Î≥¥Ïïà ÌÖåÏä§Ìä∏ ÏôÑÎ£å`, 'green');
    }

    async testAuthentication() {
        // Ïù∏Ï¶ù ÌÖåÏä§Ìä∏
        return { tests: [], passed: 0, failed: 0 };
    }

    async testAuthorization() {
        // Ïù∏Í∞Ä ÌÖåÏä§Ìä∏
        return { tests: [], passed: 0, failed: 0 };
    }

    async testInputValidation() {
        // ÏûÖÎ†• Í≤ÄÏ¶ù ÌÖåÏä§Ìä∏
        return { tests: [], passed: 0, failed: 0 };
    }

    async testRateLimiting() {
        // ÏÜçÎèÑ Ï†úÌïú ÌÖåÏä§Ìä∏
        return { tests: [], passed: 0, failed: 0 };
    }

    async testCors() {
        // CORS ÌÖåÏä§Ìä∏
        return { tests: [], passed: 0, failed: 0 };
    }

    // 5. Ïù∏ÌîÑÎùº Î≥¥Ïïà Í≤ÄÏÇ¨
    async checkInfrastructureSecurity() {
        log('\nüèóÔ∏è  Ïù∏ÌîÑÎùº Î≥¥Ïïà Í≤ÄÏÇ¨ Ï§ë...', 'cyan');

        const infraSecurity = {
            dockerSecurity: await this.checkDockerSecurity(),
            networkSecurity: await this.checkNetworkSecurity(),
            filePermissions: await this.checkFilePermissions(),
            sslCertificates: await this.checkSslCertificates(),
        };

        this.results.infrastructureSecurity = infraSecurity;

        log(`  üìä Ïù∏ÌîÑÎùº Î≥¥Ïïà Í≤ÄÏÇ¨ ÏôÑÎ£å`, 'green');
    }

    async checkDockerSecurity() {
        // Docker Î≥¥Ïïà Í≤ÄÏÇ¨
        return { issues: [], count: 0 };
    }

    async checkNetworkSecurity() {
        // ÎÑ§Ìä∏ÏõåÌÅ¨ Î≥¥Ïïà Í≤ÄÏÇ¨
        return { issues: [], count: 0 };
    }

    async checkFilePermissions() {
        // ÌååÏùº Í∂åÌïú Í≤ÄÏÇ¨
        return { issues: [], count: 0 };
    }

    async checkSslCertificates() {
        // SSL Ïù∏Ï¶ùÏÑú Í≤ÄÏÇ¨
        return { issues: [], count: 0 };
    }

    // 6. Ï¢ÖÌï© ÌèâÍ∞Ä
    evaluateOverallSecurity() {
        log('\nüìä Ï¢ÖÌï© Î≥¥Ïïà ÌèâÍ∞Ä Ï§ë...', 'cyan');

        let score = 100;

        // ÏùòÏ°¥ÏÑ± Ï∑®ÏïΩÏ†ê Í∞êÏ†ê
        const depVulns = Object.values(this.results.dependencyScan)
            .reduce((sum, result) => sum + (result.vulnerabilities?.length || 0), 0);
        score -= depVulns * 5;

        // ÏΩîÎìú Î≥¥Ïïà Ïù¥Ïäà Í∞êÏ†ê
        const codeIssues = Object.values(this.results.codeAnalysis)
            .reduce((sum, result) => sum + (result.issues?.length || 0), 0);
        score -= codeIssues * 3;

        // Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Î≥¥Ïïà Ïù¥Ïäà Í∞êÏ†ê
        const dbIssues = Object.values(this.results.databaseSecurity)
            .reduce((sum, result) => sum + (result.issues?.length || 0), 0);
        score -= dbIssues * 4;

        // API Î≥¥Ïïà Ïù¥Ïäà Í∞êÏ†ê
        const apiIssues = Object.values(this.results.apiSecurity)
            .reduce((sum, result) => sum + (result.failed || 0), 0);
        score -= apiIssues * 2;

        // Ïù∏ÌîÑÎùº Î≥¥Ïïà Ïù¥Ïäà Í∞êÏ†ê
        const infraIssues = Object.values(this.results.infrastructureSecurity)
            .reduce((sum, result) => sum + (result.issues?.length || 0), 0);
        score -= infraIssues * 3;

        this.results.overallScore = Math.max(0, Math.min(100, score));

        // Í∂åÏû•ÏÇ¨Ìï≠ ÏÉùÏÑ±
        this.generateRecommendations();

        log(`  üéØ Ï¢ÖÌï© Î≥¥Ïïà Ï†êÏàò: ${this.results.overallScore}/100`,
            this.results.overallScore >= 80 ? 'green' :
                this.results.overallScore >= 60 ? 'yellow' : 'red');
    }

    generateRecommendations() {
        const recommendations = [];

        if (this.results.overallScore < 80) {
            recommendations.push('Ï†ÑÎ∞òÏ†ÅÏù∏ Î≥¥Ïïà ÏàòÏ§ÄÏùÑ Ìñ•ÏÉÅÏãúÏºúÏïº Ìï©ÎãàÎã§.');
        }

        if (this.results.criticalIssues.length > 0) {
            recommendations.push('Ï§ëÏöîÌïú Î≥¥Ïïà Ïù¥ÏäàÎ•º Ï¶âÏãú Ìï¥Í≤∞Ìï¥Ïïº Ìï©ÎãàÎã§.');
        }

        if (this.results.warnings.length > 0) {
            recommendations.push('Í≤ΩÍ≥† ÏÇ¨Ìï≠Îì§ÏùÑ Í≤ÄÌÜ†ÌïòÍ≥† Í∞úÏÑ†ÌïòÏÑ∏Ïöî.');
        }

        this.results.recommendations = recommendations;
    }

    // 7. Î≥¥Í≥†ÏÑú ÏÉùÏÑ±
    async generateReport() {
        const report = {
            timestamp: new Date().toISOString(),
            summary: {
                overallScore: this.results.overallScore,
                criticalIssues: this.results.criticalIssues.length,
                warnings: this.results.warnings.length,
                recommendations: this.results.recommendations.length,
            },
            details: this.results,
        };

        const reportsDir = path.join(__dirname, '../reports');
        if (!fs.existsSync(reportsDir)) {
            fs.mkdirSync(reportsDir, { recursive: true });
        }

        const reportPath = path.join(reportsDir, `security-audit-${Date.now()}.json`);
        fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));

        log(`\nüìÑ Î≥¥Ïïà Í∞êÏÇ¨ Î≥¥Í≥†ÏÑú Ï†ÄÏû•: ${reportPath}`, 'green');

        return reportPath;
    }
}

// Î©îÏù∏ Ïã§Ìñâ
async function main() {
    const auditor = new SecurityAuditor();
    await auditor.runAudit();
}

if (require.main === module) {
    main().catch(console.error);
}

module.exports = SecurityAuditor;
