#!/usr/bin/env node

/**
 * üöÄ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏÑ±Îä• ÏµúÏ†ÅÌôî Ïä§ÌÅ¨Î¶ΩÌä∏
 * 
 * Ïù¥ Ïä§ÌÅ¨Î¶ΩÌä∏Îäî Îã§Ïùå ÏûëÏóÖÏùÑ ÏàòÌñâÌï©ÎãàÎã§:
 * 1. Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïù∏Îç±Ïä§ Î∂ÑÏÑù Î∞è ÏµúÏ†ÅÌôî
 * 2. ÏøºÎ¶¨ ÏÑ±Îä• Î∂ÑÏÑù
 * 3. Ïó∞Í≤∞ ÌíÄ ÏÑ§Ï†ï ÏµúÏ†ÅÌôî
 * 4. Ï∫êÏã± Ï†ÑÎûµ Íµ¨ÌòÑ
 */

const mysql = require('mysql2/promise');
const { performance } = require('perf_hooks');
const fs = require('fs');
const path = require('path');

// Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏÑ§Ï†ï
const dbConfig = {
    host: process.env.DB_HOST || 'localhost',
    port: process.env.DB_PORT || 3306,
    user: process.env.DB_USER || 'root',
    password: process.env.DB_PASSWORD || 'root',
    database: process.env.DB_NAME || 'community',
    connectionLimit: 20,
    acquireTimeout: 60000,
    timeout: 60000,
    reconnect: true
};

// ÏÉâÏÉÅ Ï†ïÏùò
const colors = {
    reset: '\x1b[0m',
    bright: '\x1b[1m',
    red: '\x1b[31m',
    green: '\x1b[32m',
    yellow: '\x1b[33m',
    blue: '\x1b[34m',
    magenta: '\x1b[35m',
    cyan: '\x1b[36m'
};

const log = (message, color = 'reset') => {
    console.log(`${colors[color]}${message}${colors.reset}`);
};

// ÏµúÏ†ÅÌôîÌï† ÌÖåÏù¥Î∏îÍ≥º Ïù∏Îç±Ïä§ Ï†ïÏùò
const optimizationQueries = [
    // ÏÇ¨Ïö©Ïûê ÌÖåÏù¥Î∏î ÏµúÏ†ÅÌôî
    {
        name: 'ÏÇ¨Ïö©Ïûê ÌÖåÏù¥Î∏î Ïù∏Îç±Ïä§ ÏµúÏ†ÅÌôî',
        queries: [
            'CREATE INDEX IF NOT EXISTS idx_users_email ON users(email)',
            'CREATE INDEX IF NOT EXISTS idx_users_username ON users(username)',
            'CREATE INDEX IF NOT EXISTS idx_users_created_at ON users(created_at)',
            'CREATE INDEX IF NOT EXISTS idx_users_status ON users(status)',
            'CREATE INDEX IF NOT EXISTS idx_users_role ON users(role)'
        ]
    },

    // Í≤åÏãúÌåê ÌÖåÏù¥Î∏î ÏµúÏ†ÅÌôî
    {
        name: 'Í≤åÏãúÌåê ÌÖåÏù¥Î∏î Ïù∏Îç±Ïä§ ÏµúÏ†ÅÌôî',
        queries: [
            'CREATE INDEX IF NOT EXISTS idx_boards_name ON boards(name)',
            'CREATE INDEX IF NOT EXISTS idx_boards_created_at ON boards(created_at)',
            'CREATE INDEX IF NOT EXISTS idx_boards_is_active ON boards(is_active)'
        ]
    },

    // Í≤åÏãúÍ∏Ä ÌÖåÏù¥Î∏î ÏµúÏ†ÅÌôî
    {
        name: 'Í≤åÏãúÍ∏Ä ÌÖåÏù¥Î∏î Ïù∏Îç±Ïä§ ÏµúÏ†ÅÌôî',
        queries: [
            'CREATE INDEX IF NOT EXISTS idx_posts_board_id ON posts(board_id)',
            'CREATE INDEX IF NOT EXISTS idx_posts_author_id ON posts(author_id)',
            'CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)',
            'CREATE INDEX IF NOT EXISTS idx_posts_updated_at ON posts(updated_at)',
            'CREATE INDEX IF NOT EXISTS idx_posts_is_published ON posts(is_published)',
            'CREATE INDEX IF NOT EXISTS idx_posts_view_count ON posts(view_count)',
            'CREATE INDEX IF NOT EXISTS idx_posts_like_count ON posts(like_count)',
            'CREATE INDEX IF NOT EXISTS idx_posts_title ON posts(title(100))',
            'CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category)',
            'CREATE INDEX IF NOT EXISTS idx_posts_board_created ON posts(board_id, created_at)',
            'CREATE INDEX IF NOT EXISTS idx_posts_author_created ON posts(author_id, created_at)'
        ]
    },

    // ÎåìÍ∏Ä ÌÖåÏù¥Î∏î ÏµúÏ†ÅÌôî
    {
        name: 'ÎåìÍ∏Ä ÌÖåÏù¥Î∏î Ïù∏Îç±Ïä§ ÏµúÏ†ÅÌôî',
        queries: [
            'CREATE INDEX IF NOT EXISTS idx_comments_post_id ON comments(post_id)',
            'CREATE INDEX IF NOT EXISTS idx_comments_author_id ON comments(author_id)',
            'CREATE INDEX IF NOT EXISTS idx_comments_parent_id ON comments(parent_id)',
            'CREATE INDEX IF NOT EXISTS idx_comments_created_at ON comments(created_at)',
            'CREATE INDEX IF NOT EXISTS idx_comments_is_deleted ON comments(is_deleted)',
            'CREATE INDEX IF NOT EXISTS idx_comments_post_created ON comments(post_id, created_at)'
        ]
    },

    // Ï±ÑÌåÖ ÌÖåÏù¥Î∏î ÏµúÏ†ÅÌôî
    {
        name: 'Ï±ÑÌåÖ ÌÖåÏù¥Î∏î Ïù∏Îç±Ïä§ ÏµúÏ†ÅÌôî',
        queries: [
            'CREATE INDEX IF NOT EXISTS idx_chat_rooms_created_at ON chat_rooms(created_at)',
            'CREATE INDEX IF NOT EXISTS idx_chat_rooms_is_active ON chat_rooms(is_active)',
            'CREATE INDEX IF NOT EXISTS idx_chat_messages_room_id ON chat_messages(room_id)',
            'CREATE INDEX IF NOT EXISTS idx_chat_messages_sender_id ON chat_messages(sender_id)',
            'CREATE INDEX IF NOT EXISTS idx_chat_messages_created_at ON chat_messages(created_at)',
            'CREATE INDEX IF NOT EXISTS idx_chat_messages_room_created ON chat_messages(room_id, created_at)'
        ]
    },

    // ÌååÏùº Ï≤®Î∂Ä ÌÖåÏù¥Î∏î ÏµúÏ†ÅÌôî
    {
        name: 'ÌååÏùº Ï≤®Î∂Ä ÌÖåÏù¥Î∏î Ïù∏Îç±Ïä§ ÏµúÏ†ÅÌôî',
        queries: [
            'CREATE INDEX IF NOT EXISTS idx_post_attachments_post_id ON post_attachments(post_id)',
            'CREATE INDEX IF NOT EXISTS idx_post_attachments_file_type ON post_attachments(file_type)',
            'CREATE INDEX IF NOT EXISTS idx_post_attachments_created_at ON post_attachments(created_at)'
        ]
    }
];

// ÏøºÎ¶¨ ÏÑ±Îä• Î∂ÑÏÑù ÏøºÎ¶¨
const performanceQueries = [
    {
        name: 'ÎäêÎ¶∞ ÏøºÎ¶¨ Î∂ÑÏÑù',
        query: `
      SELECT 
        query_time,
        lock_time,
        rows_sent,
        rows_examined,
        sql_text
      FROM mysql.slow_log 
      WHERE start_time > DATE_SUB(NOW(), INTERVAL 1 DAY)
      ORDER BY query_time DESC 
      LIMIT 10
    `
    },
    {
        name: 'ÌÖåÏù¥Î∏î ÌÜµÍ≥Ñ',
        query: `
      SELECT 
        table_name,
        table_rows,
        data_length,
        index_length,
        (data_length + index_length) as total_size,
        ROUND(((data_length + index_length) / 1024 / 1024), 2) as size_mb
      FROM information_schema.tables 
      WHERE table_schema = DATABASE()
      ORDER BY total_size DESC
    `
    },
    {
        name: 'Ïù∏Îç±Ïä§ ÏÇ¨Ïö©Î•†',
        query: `
      SELECT 
        table_name,
        index_name,
        cardinality,
        ROUND((cardinality / table_rows) * 100, 2) as selectivity
      FROM information_schema.statistics s
      JOIN information_schema.tables t ON s.table_name = t.table_name
      WHERE s.table_schema = DATABASE()
      ORDER BY selectivity DESC
    `
    }
];

async function createConnection() {
    try {
        const connection = await mysql.createConnection(dbConfig);
        log('‚úÖ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ ÏÑ±Í≥µ', 'green');
        return connection;
    } catch (error) {
        log(`‚ùå Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ Ïã§Ìå®: ${error.message}`, 'red');
        throw error;
    }
}

async function executeOptimization(connection) {
    log('\nüöÄ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏµúÏ†ÅÌôî ÏãúÏûë...', 'cyan');

    let totalQueries = 0;
    let successQueries = 0;
    let failedQueries = 0;

    for (const optimization of optimizationQueries) {
        log(`\nüìä ${optimization.name}`, 'yellow');

        for (const query of optimization.queries) {
            totalQueries++;
            try {
                const startTime = performance.now();
                await connection.execute(query);
                const endTime = performance.now();
                const duration = (endTime - startTime).toFixed(2);

                log(`  ‚úÖ Ïù∏Îç±Ïä§ ÏÉùÏÑ± ÏôÑÎ£å (${duration}ms)`, 'green');
                successQueries++;
            } catch (error) {
                if (error.code === 'ER_DUP_KEYNAME') {
                    log(`  ‚ö†Ô∏è  Ïù∏Îç±Ïä§ Ïù¥ÎØ∏ Ï°¥Ïû¨: ${query.split(' ')[5]}`, 'yellow');
                    successQueries++; // Ïù¥ÎØ∏ Ï°¥Ïû¨ÌïòÎäî Ïù∏Îç±Ïä§Îäî ÏÑ±Í≥µÏúºÎ°ú Í∞ÑÏ£º
                } else {
                    log(`  ‚ùå ÏøºÎ¶¨ Ïã§Ìå®: ${error.message}`, 'red');
                    failedQueries++;
                }
            }
        }
    }

    log(`\nüìà ÏµúÏ†ÅÌôî Í≤∞Í≥º:`, 'cyan');
    log(`  Ï¥ù ÏøºÎ¶¨: ${totalQueries}Í∞ú`, 'blue');
    log(`  ÏÑ±Í≥µ: ${successQueries}Í∞ú`, 'green');
    log(`  Ïã§Ìå®: ${failedQueries}Í∞ú`, 'red');

    return { totalQueries, successQueries, failedQueries };
}

async function analyzePerformance(connection) {
    log('\nüîç ÏÑ±Îä• Î∂ÑÏÑù ÏãúÏûë...', 'cyan');

    const results = {};

    for (const analysis of performanceQueries) {
        try {
            log(`\nüìä ${analysis.name}`, 'yellow');
            const [rows] = await connection.execute(analysis.query);

            if (rows.length === 0) {
                log('  Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.', 'yellow');
            } else {
                results[analysis.name] = rows;

                // Í≤∞Í≥ºÎ•º ÌÖåÏù¥Î∏î ÌòïÌÉúÎ°ú Ï∂úÎ†•
                if (rows.length > 0) {
                    const columns = Object.keys(rows[0]);
                    const maxLengths = columns.map(col => Math.max(col.length, ...rows.map(row => String(row[col] || '').length)));

                    // Ìó§Îçî Ï∂úÎ†•
                    let header = '  |';
                    columns.forEach((col, i) => {
                        header += ` ${col.padEnd(maxLengths[i])} |`;
                    });
                    log(header, 'blue');

                    // Íµ¨Î∂ÑÏÑ†
                    let separator = '  |';
                    maxLengths.forEach(length => {
                        separator += ` ${'-'.repeat(length)} |`;
                    });
                    log(separator, 'blue');

                    // Îç∞Ïù¥ÌÑ∞ Ï∂úÎ†• (ÏµúÎåÄ 10Ìñâ)
                    rows.slice(0, 10).forEach(row => {
                        let rowStr = '  |';
                        columns.forEach((col, i) => {
                            rowStr += ` ${String(row[col] || '').padEnd(maxLengths[i])} |`;
                        });
                        log(rowStr, 'white');
                    });

                    if (rows.length > 10) {
                        log(`  ... Î∞è ${rows.length - 10}Í∞ú Îçî`, 'yellow');
                    }
                }
            }
        } catch (error) {
            log(`  ‚ùå Î∂ÑÏÑù Ïã§Ìå®: ${error.message}`, 'red');
        }
    }

    return results;
}

async function optimizeConnectionPool(connection) {
    log('\nüîß Ïó∞Í≤∞ ÌíÄ ÏµúÏ†ÅÌôî...', 'cyan');

    try {
        // ÌòÑÏû¨ Ïó∞Í≤∞ ÏÑ§Ï†ï ÌôïÏù∏
        const [variables] = await connection.execute(`
      SELECT 
        @@max_connections as max_connections,
        @@max_connect_errors as max_connect_errors,
        @@connect_timeout as connect_timeout,
        @@wait_timeout as wait_timeout,
        @@interactive_timeout as interactive_timeout
    `);

        log('ÌòÑÏû¨ Ïó∞Í≤∞ ÏÑ§Ï†ï:', 'yellow');
        variables.forEach(variable => {
            Object.entries(variable).forEach(([key, value]) => {
                log(`  ${key}: ${value}`, 'blue');
            });
        });

        // Í∂åÏû• ÏÑ§Ï†ï Ï†úÏïà
        log('\nÍ∂åÏû• ÏÑ§Ï†ï:', 'green');
        log('  max_connections: 200-500 (ÏÑúÎ≤Ñ Î©îÎ™®Î¶¨Ïóê Îî∞Îùº)', 'green');
        log('  connect_timeout: 10', 'green');
        log('  wait_timeout: 28800 (8ÏãúÍ∞Ñ)', 'green');
        log('  interactive_timeout: 28800 (8ÏãúÍ∞Ñ)', 'green');

    } catch (error) {
        log(`‚ùå Ïó∞Í≤∞ ÌíÄ Î∂ÑÏÑù Ïã§Ìå®: ${error.message}`, 'red');
    }
}

async function generateOptimizationReport(results) {
    const report = {
        timestamp: new Date().toISOString(),
        optimization: {
            totalQueries: results.totalQueries,
            successQueries: results.successQueries,
            failedQueries: results.failedQueries,
            successRate: ((results.successQueries / results.totalQueries) * 100).toFixed(2) + '%'
        },
        recommendations: [
            'Ï†ïÍ∏∞Ï†ÅÏù∏ ANALYZE TABLE Ïã§ÌñâÏúºÎ°ú ÌÜµÍ≥Ñ ÏóÖÎç∞Ïù¥Ìä∏',
            'ÎäêÎ¶∞ ÏøºÎ¶¨ Î°úÍ∑∏ Î™®ÎãàÌÑ∞ÎßÅ ÏÑ§Ï†ï',
            'Ïù∏Îç±Ïä§ ÏÇ¨Ïö©Î•† Î™®ÎãàÌÑ∞ÎßÅ',
            'ÌÖåÏù¥Î∏î ÌååÌã∞ÏÖîÎãù Í≥†Î†§ (ÎåÄÏö©Îüâ ÌÖåÏù¥Î∏î)',
            'ÏøºÎ¶¨ Ï∫êÏãú ÌôúÏÑ±Ìôî Í≤ÄÌÜ†'
        ]
    };

    const reportsDir = path.join(__dirname, '../reports');
    if (!fs.existsSync(reportsDir)) {
        fs.mkdirSync(reportsDir, { recursive: true });
    }

    const reportPath = path.join(reportsDir, `database-optimization-${Date.now()}.json`);
    fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));

    log(`\nüìÑ ÏµúÏ†ÅÌôî Î≥¥Í≥†ÏÑú Ï†ÄÏû•: ${reportPath}`, 'green');

    return report;
}

async function main() {
    log('üöÄ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏÑ±Îä• ÏµúÏ†ÅÌôî Ïä§ÌÅ¨Î¶ΩÌä∏ ÏãúÏûë', 'bright');
    log('=' * 50, 'cyan');

    let connection;

    try {
        // Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞
        connection = await createConnection();

        // ÏµúÏ†ÅÌôî Ïã§Ìñâ
        const optimizationResults = await executeOptimization(connection);

        // ÏÑ±Îä• Î∂ÑÏÑù
        await analyzePerformance(connection);

        // Ïó∞Í≤∞ ÌíÄ ÏµúÏ†ÅÌôî
        await optimizeConnectionPool(connection);

        // Î≥¥Í≥†ÏÑú ÏÉùÏÑ±
        const report = await generateOptimizationReport(optimizationResults);

        log('\nüéâ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏµúÏ†ÅÌôî ÏôÑÎ£å!', 'green');
        log(`ÏÑ±Í≥µÎ•†: ${report.optimization.successRate}`, 'green');

    } catch (error) {
        log(`\n‚ùå ÏµúÏ†ÅÌôî Ïã§Ìå®: ${error.message}`, 'red');
        process.exit(1);
    } finally {
        if (connection) {
            await connection.end();
            log('Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ Ï¢ÖÎ£å', 'yellow');
        }
    }
}

// Ïä§ÌÅ¨Î¶ΩÌä∏ Ïã§Ìñâ
if (require.main === module) {
    main().catch(console.error);
}

module.exports = {
    createConnection,
    executeOptimization,
    analyzePerformance,
    optimizeConnectionPool,
    generateOptimizationReport
};
