<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <title>간단 기능 테스트 (frontend/)</title>
    <!--
            NOTE: 새로운 백엔드 엔드포인트(예: /api/xxx) 추가 시
            1) 아래 체크리스트 buildTests() 배열에 테스트 항목을 추가하고
            2) 필요하면 전용 UI 카드(.test div) + 수동 버튼도 구성
            3) 성능 측정이 필요한 경우 performance.now() 로 ms 기록 후 mark(extra)에 표기
            4) 재시도 대상 포함하려면 key 고유값 부여 (기존과 중복 금지)
            5) 결과 구조는 CHECK_RESULTS[key] = { ok, extra, ms, raw } 형태 유지
        -->
    <style>
        body {
            font-family: Arial;
            padding: 20px;
            background: #f5f5f5;
        }

        .test {
            background: #fff;
            margin: 10px 0;
            padding: 15px;
            border-radius: 5px;
            border-left: 4px solid #007acc;
        }

        button {
            background: #007acc;
            color: #fff;
            border: none;
            padding: 8px 16px;
            margin: 5px;
            border-radius: 3px;
            cursor: pointer;
        }

        button:hover {
            background: #005999;
        }

        .result {
            margin: 10px 0;
            padding: 10px;
            border-radius: 3px;
            font-family: monospace;
            white-space: pre-wrap;
        }

        .success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
    </style>
</head>

<body>
    <h1>🚀 커뮤니티 플랫폼 종합 테스트 (단일 체크리스트)</h1>
    <p style="font-size:12px;color:#666;">모든 테스트는 아래 "빠른 기능 체크리스트" 에 통합되었습니다. 실패가 발생해도 중단하지 않고 끝까지 수행합니다.</p>

    <!-- 새 체크리스트 섹션 -->
    <div class="test" id="checklist-box">
        <h3>✅ 빠른 기능 체크리스트</h3>
        <div style="font-size:12px;color:#555;line-height:1.4;">아래 항목을 순서대로 자동 점검하거나, 개별 실행 버튼을 눌러 기능을 검증할 수 있습니다.</div>
        <div style="margin:6px 0;">
            <button onclick="runChecklist()" style="background:#2f855a;">체크리스트 실행</button>
            <button onclick="retryFailed()" style="background:#b45309;">실패만 재시도</button>
            <button onclick="resetChecklist()" style="background:#6b7280;">초기화</button>
            <button onclick="exportChecklistJson()" style="background:#1d4ed8;">JSON Export</button>
        </div>
        <ul id="checklist" style="list-style:none;padding-left:0;margin:0;font-size:13px;line-height:1.5;">
            <li id="cl-health">[ ] Health API</li>
            <li id="cl-help">[ ] Help API</li>
            <li id="cl-metrics">[ ] Metrics API</li>
            <li id="cl-trending">[ ] Trending (응답/소스)</li>
            <li id="cl-trending-perf">[ ] Trending 성능(5회 avg)</li>
            <li id="cl-home">[ ] /home 통합</li>
            <li id="cl-search">[ ] 검색(Search)</li>
            <li id="cl-boards">[ ] Boards 목록</li>
            <li id="cl-categories">[ ] Categories 목록</li>
            <li id="cl-metrics-latency">[ ] Metrics p95 검사</li>
            <li id="cl-chat-load">[ ] Chat 부하</li>
            <li id="cl-login">[ ] Google 로그인 (test-mode 가능)</li>
            <li id="cl-me">[ ] /auth/me (identities 포함)</li>
            <li id="cl-post">[ ] 게시글 작성 & 상세(author 확인)</li>
            <li id="cl-chat">[ ] 채팅 전송 & 조회</li>
            <li id="cl-latest500">[ ] 최신 채팅 500 로드</li>
            <li id="cl-security">[ ] 보안 헤더(CSP)</li>
        </ul>
        <div id="checklist-log" class="result info" style="margin-top:8px;">대기 중</div>
    </div>

    <div class="test" id="google-auth-box">
        <h3>🔐 구글 로그인</h3>
        <div style="font-size:12px;color:#555;line-height:1.4;">
            아래 버튼을 눌러 로그인 창을 직접 열 수 있습니다. (Google One Tap 자동 버튼 + 커스텀 둘 다 제공)
        </div>
        <div style="margin:6px 0;">
            <button id="custom-google-btn" style="background:#DB4437;">▶ 구글 로그인 창 열기</button>
            <button onclick="testGoogleTestMode()" style="background:#555;">(테스트) test-mode 토큰 로그인</button>
            <button onclick="fetchMe()" style="background:#444;">/me 조회</button>
            <button onclick="logoutAll()" style="background:#9d174d;">로그아웃</button>
        </div>
        <div id="g_id_signin" style="margin-top:4px;"></div>
        <div id="google-login-result" class="result info">미로그인</div>
    </div>

    <div class="test" id="post-create-box">
        <h3>✍️ 로그인 후 게시글 작성 테스트</h3>
        <div style="font-size:12px;color:#555;">구글 로그인(Test-mode 가능) → 토큰 저장 → 아래에서 글 작성 (author 자동 = display_name)
        </div>
        <label>게시판 ID: <input type="text" id="post-board" value="free" style="width:120px;" /></label>
        <br />
        <input type="text" id="post-title" placeholder="제목" value="테스트 제목" style="width:300px;" />
        <br />
        <textarea id="post-content" placeholder="내용" style="width:300px;height:80px;">간단 내용</textarea>
        <br />
        <button onclick="createPost()">글 작성</button>
        <div id="post-create-result" class="result info">로그인 후 사용하세요</div>
    </div>

    <!-- 이전 auto-suite 제거: global-suite + checklist 통합으로 대체 -->

    <div class="test">
        <h3>🔍 서버 상태</h3>
        <button onclick="test('health')">Health Check</button>
        <button onclick="test('help')">API 문서</button>
        <button onclick="test('metrics')">메트릭스</button>
        <div id="server-result" class="result"></div>
    </div>

    <div class="test">
        <h3>⚡ Trending API (Redis 최적화)</h3>
        <button onclick="test('trending')">단일 요청</button>
        <button onclick="testPerformance()">성능 테스트</button>
        <div id="trending-result" class="result"></div>
    </div>

    <div class="test">
        <h3>🏆 Trending/Ranking 샘플 다회 호출</h3>
        <div style="font-size:12px;color:#555;">Redis 메모리 캐시(source=memory_cache) 전환 및 평균 시간 관찰</div>
        <button onclick="multiTrending()" style="background:#9333ea;">10회 연속 호출</button>
        <div id="trending-multi-result" class="result"></div>
    </div>

    <div class="test">
        <h3>💬 채팅 기능</h3>
        <input type="text" id="msg" placeholder="메시지 입력" value="테스트 메시지" />
        <button onclick="sendMessage()">전송</button>
        <button onclick="sendRandomMessage()" style="background:#7c3aed;">랜덤 전송</button>
        <button onclick="test('chat')">조회</button>
        <div id="chat-result" class="result"></div>
    </div>

    <div class="test">
        <h3>🧪 Chat 부하 테스트</h3>
        <div style="font-size:12px;color:#555;">N회 병렬 전송 후 서버 응답시간 통계(ms) 산출</div>
        <label>총 메시지 수 N: <input type="number" id="chat-load-n" value="30" style="width:80px;" /></label>
        <label>동시성(concurrency): <input type="number" id="chat-load-c" value="5" style="width:60px;" /></label>
        <button onclick="runChatLoad()" style="background:#dc2626;">실행</button>
        <div id="chat-load-result" class="result info">대기 중</div>
    </div>

    <div class="test">
        <h3>🛡️ 보안 헤더</h3>
        <button onclick="checkSecurity()">보안 확인</button>
        <div id="security-result" class="result"></div>
    </div>

    <div class="test">
        <h3>🧵 최신 채팅 500 (모든 커뮤니티)</h3>
        <button onclick="loadLatest500()">불러오기</button>
        <button onclick="autoRefreshLatest()">30초 자동갱신 시작</button>
        <button onclick="stopAutoRefreshLatest()">자동갱신 중지</button>
        <div style="font-size:12px;color:#555;">각 커뮤니티 별 Redis/DB 최신 메시지 합산 후 timestamp 역순 정렬 → 상위 500 표시</div>
        <div id="latest500-summary" class="result info">아직 로드 안됨</div>
        <div id="latest500-list" class="result"
            style="max-height:300px; overflow-y:auto; background:#fff; border:1px solid #ddd;"></div>
    </div>

    <script>
        const API = 'http://localhost:50000/api';
        let ACCESS_TOKEN = null;
        function show(id, text, type = 'info') { const el = document.getElementById(id); if (!el) return; el.className = `result ${type}`; el.textContent = text; }
        async function request(url, opt = {}) { try { const headers = { 'Content-Type': 'application/json', ...(opt.headers || {}) }; if (ACCESS_TOKEN) headers['Authorization'] = 'Bearer ' + ACCESS_TOKEN; const r = await fetch(url, { ...opt, headers }); const data = await r.json().catch(() => ({})); if (!r.ok) throw new Error(data.error || 'HTTP ' + r.status); return { ok: true, data, headers: r.headers }; } catch (e) { return { ok: false, error: e.message }; } }
        async function test(kind) {
            const map = {
                health: async () => { const r = await request(`${API}/health`); return r.ok ? `✅ 서버 정상\n시간: ${new Date(r.data.ts).toLocaleString()}` : `❌ 실패: ${r.error}`; },
                help: async () => { const r = await request(`${API}/help`); return r.ok ? `✅ API 문서\n엔드포인트: ${Object.keys(r.data.endpoints).length}` : `❌ 실패: ${r.error}`; },
                metrics: async () => { const r = await request(`${API}/metrics`); return r.ok ? `✅ 메트릭스\n요청 수: ${r.data.totalRequests || 'N/A'}` : `❌ 실패: ${r.error}`; },
                trending: async () => { const s = performance.now(); const r = await request(`${API}/trending`); const ms = (performance.now() - s).toFixed(1); return r.ok ? `✅ Trending ${ms}ms source=${r.data.source}` : `❌ 실패: ${r.error}`; },
                chat: async () => { const r = await request(`${API}/chat/test/messages`); return r.ok ? `✅ 채팅 메시지 ${(r.data.messages || []).length}개` : `❌ 실패: ${r.error}`; }
            };
            const id = ['health', 'help', 'metrics'].includes(kind) ? 'server-result' : kind === 'trending' ? 'trending-result' : 'chat-result';
            show(id, '⏳ 진행 중...', 'info'); const out = await map[kind](); show(id, out, out.startsWith('✅') ? 'success' : 'error');
        }
        async function testPerformance() { show('trending-result', '⚡ 성능 5회...', 'info'); const times = []; const sources = []; for (let i = 0; i < 5; i++) { const s = performance.now(); const r = await request(`${API}/trending`); const ms = performance.now() - s; times.push(ms); if (r.ok) sources.push(r.data.source); } const avg = (times.reduce((a, b) => a + b) / times.length).toFixed(1); show('trending-result', `✅ 평균 ${avg}ms 소스: ${[...new Set(sources)].join(' → ')}`, 'success'); }
        async function multiTrending() { show('trending-multi-result', '⏳ 10회 수행...', 'info'); const times = []; const srcSet = new Set(); for (let i = 0; i < 10; i++) { const s = performance.now(); const r = await request(`${API}/trending`); const ms = performance.now() - s; times.push(ms); if (r.ok) srcSet.add(r.data.source); await new Promise(rz => setTimeout(rz, 50)); } const avg = (times.reduce((a, b) => a + b, 0) / times.length).toFixed(1); show('trending-multi-result', `✅ 10회 평균 ${avg}ms sources=[${[...srcSet].join(',')}]`, 'success'); }
        async function sendMessage() { const msg = document.getElementById('msg').value; if (!msg.trim()) return show('chat-result', '❌ 메시지 필요', 'error'); show('chat-result', '📤 전송...', 'info'); const r = await request(`${API}/chat/test/messages`, { method: 'POST', body: JSON.stringify({ content: msg, author: '테스터' }) }); show('chat-result', r.ok ? `✅ 전송 성공 id=${r.data.message?.id}` : `❌ 실패: ${r.error}`, r.ok ? 'success' : 'error'); }
        function sendRandomMessage() {
            const samples = ['랜덤😀', 'Ping', 'Stress ' + Math.random().toString(36).slice(2, 8), 'LoadTest', 'Echo', '테스트' + Date.now()];
            document.getElementById('msg').value = samples[Math.floor(Math.random() * samples.length)];
            sendMessage();
        }
        async function checkSecurity() { show('security-result', '🔍 확인 중...', 'info'); try { const resp = await fetch(`${API}/health`); const csp = resp.headers.get('Content-Security-Policy'); const cors = resp.headers.get('Access-Control-Allow-Origin'); const frame = resp.headers.get('X-Frame-Options'); show('security-result', `✅ 보안 헤더\nCSP:${csp ? '있음' : '없음'}\nCORS:${cors || '없음'}\nX-Frame:${frame || '없음'}`, 'success'); } catch (e) { show('security-result', `❌ 실패: ${e.message}`, 'error'); } }
        // runAllSmoke 제거됨 -> runChecklist(true)로 대체

        let latestTimer = null;
        async function loadLatest500() {
            show('latest500-summary', '⏳ 로딩...', 'info');
            const communities = ['free', 'news', 'game', 'image', 'default', 'test'];
            // 병렬 fetch
            const fetches = await Promise.all(communities.map(c => fetch(`${API}/chat/${c}/messages?limit=500`).then(r => r.json().catch(() => ({ error: true }))).catch(() => ({ error: true }))));
            let merged = [];
            const perStat = [];
            fetches.forEach((res, idx) => {
                const name = communities[idx];
                if (res && !res.error && res.messages) {
                    perStat.push(`${name}:${res.messages.length}`);
                    res.messages.forEach(m => {
                        const ts = Date.parse(m.timestamp || m.created_at || m.createdAt || m.time || Date.now());
                        merged.push({
                            community: name,
                            id: m.id,
                            author: m.author || m.username || '익명',
                            content: m.content,
                            ts
                        });
                    });
                } else {
                    perStat.push(`${name}:ERR`);
                }
            });
            merged.sort((a, b) => b.ts - a.ts);
            if (merged.length > 500) merged = merged.slice(0, 500);
            const listBox = document.getElementById('latest500-list');
            listBox.textContent = merged.map(m => {
                const t = new Date(m.ts).toLocaleTimeString();
                return `[${t}][${m.community}] ${m.author}: ${m.content}`;
            }).join('\n');
            show('latest500-summary', `✅ 총 ${merged.length}개 (커뮤니티별: ${perStat.join(', ')})`, 'success');
        }
        function autoRefreshLatest() {
            if (latestTimer) return; loadLatest500();
            latestTimer = setInterval(loadLatest500, 30000);
            show('latest500-summary', '🔁 30초마다 자동 새로고침 활성', 'info');
        }
        function stopAutoRefreshLatest() {
            if (latestTimer) { clearInterval(latestTimer); latestTimer = null; show('latest500-summary', '⏹️ 자동 새로고침 중지', 'info'); }
        }
        async function fetchMe() {
            if (!ACCESS_TOKEN) return show('google-login-result', '❌ 토큰 없음', 'error');
            const r = await request(API + '/auth/me');
            if (r.ok) {
                show('google-login-result', '✅ /me\nuserId=' + r.data.user.id + '\nname=' + r.data.user.display_name + '\nemail=' + (r.data.user.email || '') + '\nidentities=' + r.data.user.identities.length, 'success');
            } else show('google-login-result', '❌ /me 실패 ' + r.error, 'error');
        }
        function logoutAll() {
            ACCESS_TOKEN = null;
            LAST_GOOGLE_EMAIL = null;
            logChecklist('🔒 로그아웃/토큰 초기화 완료');
            show('google-login-result', '로그아웃됨', 'info');
        }
        async function createPost() {
            if (!ACCESS_TOKEN) return show('post-create-result', '❌ 먼저 로그인 필요', 'error');
            const board = document.getElementById('post-board').value.trim();
            const title = document.getElementById('post-title').value.trim();
            const content = document.getElementById('post-content').value;
            if (!board || !title) return show('post-create-result', '❌ board/title 필요', 'error');
            show('post-create-result', '⏳ 생성 중...', 'info');
            const res = await request(`${API}/boards/${board}/posts`, { method: 'POST', body: JSON.stringify({ title, content }) });
            if (!res.ok) return show('post-create-result', '❌ 실패 ' + res.error, 'error');
            const pid = res.data.id;
            // 상세 조회
            const detail = await request(`${API}/posts/${pid}`);
            if (detail.ok) {
                show('post-create-result', `✅ 생성됨 id=${pid}\nboard=${board}\nauthor=${detail.data.author}\ntitle=${detail.data.title}`, 'success');
            } else {
                show('post-create-result', `⚠️ 생성은 되었으나 상세 조회 실패 id=${pid}`, 'error');
            }
        }

        // --- Google Identity Services (Enhanced) ---
        // Client ID updated (2025-09-21): previous n38qlgmu... replaced with rl00r389... per request
        const GOOGLE_CID = '425966176847-rl00r389id6rc891fmcsi98ab3cneak2.apps.googleusercontent.com';
        let LAST_GOOGLE_EMAIL = null;
        let REAL_LOGIN_IN_PROGRESS = false;

        async function exchangeGoogleToken(idToken) {
            if (REAL_LOGIN_IN_PROGRESS) return;
            REAL_LOGIN_IN_PROGRESS = true;
            show('google-login-result', '⏳ 서버 토큰 교환 중...', 'info');
            try {
                const r = await fetch(API + '/auth/google', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ idToken }) });
                const js = await r.json().catch(() => ({}));
                if (r.ok && js.access) {
                    ACCESS_TOKEN = js.access;
                    show('google-login-result', `✅ 로그인 성공\nemail=${LAST_GOOGLE_EMAIL || '(unknown)'}\nmode=real`, 'success');
                    logChecklist('auth: real login ok', 'success');
                } else {
                    show('google-login-result', '❌ 교환 실패 ' + (js.error || r.status), 'error');
                    logChecklist('auth exchange fail: ' + (js.error || r.status), 'error');
                }
            } catch (e) {
                show('google-login-result', '❌ 네트워크 오류: ' + e.message, 'error');
                logChecklist('auth exchange net err: ' + e.message, 'error');
            } finally {
                REAL_LOGIN_IN_PROGRESS = false;
            }
        }

        async function handleGoogleCredential(resp) {
            try {
                if (resp && resp.credential) {
                    const idToken = resp.credential;
                    const isTestMode = idToken.startsWith('test-google:');
                    if (!isTestMode) {
                        try {
                            const parts = idToken.split('.');
                            if (parts.length >= 2) {
                                const payload = JSON.parse(atob(parts[1].replace(/-/g, '+').replace(/_/g, '/')));
                                LAST_GOOGLE_EMAIL = payload.email || null;
                                const nowSec = Math.floor(Date.now() / 1000);
                                let warn = '';
                                if (payload.aud && payload.aud !== GOOGLE_CID) warn += `aud mismatch(expected ${GOOGLE_CID} got ${payload.aud}) `;
                                if (payload.exp && payload.exp < nowSec) warn += 'token expired ';
                                else if (payload.exp && payload.exp - nowSec < 60) warn += 'token expiring(<60s) ';
                                if (warn) {
                                    logChecklist('⚠️ Google 토큰 경고: ' + warn.trim(), 'error');
                                    const box = document.getElementById('google-login-result');
                                    if (box) box.textContent += `\n[경고] ${warn.trim()}`;
                                } else {
                                    logChecklist('Google 토큰 aud/exp 정상', 'info');
                                }
                            }
                        } catch { }
                        await exchangeGoogleToken(idToken);
                    } else {
                        show('google-login-result', '⚠️ test-mode 토큰 수신 (체크리스트용)', 'info');
                    }
                }
            } catch (e) {
                show('google-login-result', '❌ credential 처리 실패 ' + e.message, 'error');
            }
        }

        function initGoogle() {
            if (!(window.google && google.accounts && google.accounts.id)) return;
            try {
                google.accounts.id.initialize({ client_id: GOOGLE_CID, callback: handleGoogleCredential, ux_mode: 'popup' });
                google.accounts.id.renderButton(document.getElementById('g_id_signin'), { theme: 'outline', size: 'large', width: 250 });
            } catch (e) {
                show('google-login-result', '❌ 초기화 실패: ' + e.message, 'error');
            }
        }

        function enhanceMultiAccount() {
            try { if (window.google && google.accounts && google.accounts.id) google.accounts.id.disableAutoSelect(); } catch { }
            const box = document.getElementById('google-auth-box');
            if (box && !document.getElementById('google-reset-btn')) {
                const btn = document.createElement('button');
                btn.id = 'google-reset-btn';
                btn.style.background = '#8b5cf6';
                btn.textContent = '🔄 계정 변경 / 재선택';
                btn.onclick = async () => {
                    try {
                        if (window.google && google.accounts && google.accounts.id) {
                            google.accounts.id.revoke(LAST_GOOGLE_EMAIL || undefined, () => {
                                show('google-login-result', '♻️ 계정 세션 초기화, 다시 선택창 요청 중...', 'info');
                                setTimeout(() => { try { google.accounts.id.prompt(n => { if (n.isNotDisplayed && n.isNotDisplayed()) show('google-login-result', '⚠️ 표시 실패: ' + n.getNotDisplayedReason(), 'error'); }); } catch (e) { show('google-login-result', '❌ prompt 오류: ' + e.message, 'error'); } }, 300);
                            });
                        } else {
                            show('google-login-result', '❌ Google SDK 준비 안됨', 'error');
                        }
                    } catch (e) {
                        show('google-login-result', '❌ 계정 초기화 실패: ' + e.message, 'error');
                    }
                };
                const firstDiv = box.querySelector('div');
                if (firstDiv) firstDiv.appendChild(btn);
            }
        }

        function attachCustomGoogleButton() {
            const btn = document.getElementById('custom-google-btn');
            if (!btn || btn._gBound) return;
            btn._gBound = true;
            btn.addEventListener('click', () => {
                if (!(window.google && google.accounts && google.accounts.id)) {
                    show('google-login-result', '❌ Google SDK 미초기화', 'error');
                    return;
                }
                show('google-login-result', '⏳ 로그인 팝업 요청...', 'info');
                try {
                    google.accounts.id.prompt(n => {
                        try {
                            if (!n) return;
                            if (n.isNotDisplayed && n.isNotDisplayed()) show('google-login-result', '⚠️ 표시 실패: ' + n.getNotDisplayedReason(), 'error');
                            else if (n.isSkippedMoment && n.isSkippedMoment()) show('google-login-result', '⚠️ 스킵: ' + n.getSkippedReason(), 'error');
                        } catch { }
                    });
                } catch (e) {
                    show('google-login-result', '❌ prompt 오류: ' + e.message, 'error');
                }
            });
        }

        async function testGoogleTestMode() {
            show('google-login-result', '⏳ test-mode 로그인...', 'info');
            try {
                const fake = 'test-google:manual:' + Date.now() + ':tester@test.local';
                const r = await fetch(API + '/auth/google', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ idToken: fake }) });
                const js = await r.json().catch(() => ({}));
                if (r.ok && js.access) { ACCESS_TOKEN = js.access; show('google-login-result', '✅ test-mode 로그인 성공', 'success'); logChecklist('auth: test-mode login ok', 'success'); }
                else show('google-login-result', '❌ test-mode 실패 ' + (js.error || r.status), 'error');
            } catch (e) { show('google-login-result', '❌ test-mode 네트워크 오류 ' + e.message, 'error'); }
        }

        function initGoogleEnhanced() { try { initGoogle(); } catch { } enhanceMultiAccount(); attachCustomGoogleButton(); }

        // Google 스크립트 로더 (기존 유지)
        window.addEventListener('load', () => {
            const s = document.createElement('script');
            s.src = 'https://accounts.google.com/gsi/client';
            s.async = true; s.defer = true; s.onload = initGoogleEnhanced; s.onerror = () => show('google-login-result', '❌ 구글 스크립트 로드 실패', 'error');
            document.head.appendChild(s);
        });

        // 체크리스트 관련 스크립트
        function logChecklist(msg, type = 'info') { const box = document.getElementById('checklist-log'); if (!box) return; const prev = box.textContent === '대기 중' ? '' : box.textContent + '\n'; box.className = 'result ' + (type === 'error' ? 'error' : type === 'success' ? 'success' : 'info'); box.textContent = prev + msg; }
        function mark(id, ok, extra = '') { const el = document.getElementById(id); if (!el) return; const prefix = ok ? '[✔]' : '[✖]'; el.textContent = prefix + ' ' + el.textContent.replace(/^\[[^\]]+\]\s*/, '').split(' (')[0] + (extra ? ` (${extra})` : ''); if (ok) el.style.color = '#047857'; else el.style.color = '#dc2626'; }
        // 전역 체크리스트 결과 저장 객체
        let CHECK_RESULTS = {};
        function resetChecklist() {
            CHECK_RESULTS = {};
            ['cl-health', 'cl-help', 'cl-metrics', 'cl-trending', 'cl-trending-perf', 'cl-home', 'cl-search', 'cl-boards', 'cl-categories', 'cl-metrics-latency', 'cl-chat-load', 'cl-login', 'cl-me', 'cl-post', 'cl-chat', 'cl-latest500', 'cl-security'].forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.textContent = el.textContent.replace(/^[\[[^\]]+\]\s*/, '[ ] ');
                    el.style.color = '';
                }
            });
            const box = document.getElementById('checklist-log');
            if (box) { box.textContent = '대기 중'; box.className = 'result info'; }
        }
        // TEST 정의를 runChecklist 밖에서도 재사용 (실패 재시도) 하기 위해 팩토리 함수로 분리
        function buildTests() {
            return [
                { id: 'cl-health', key: 'health', run: async () => { const r = await request(API + '/health'); return { ok: r.ok, extra: '', raw: r }; } },
                { id: 'cl-help', key: 'help', run: async () => { const r = await request(API + '/help'); const ep = r.ok ? Object.keys(r.data.endpoints || {}).length : 0; return { ok: r.ok, extra: r.ok ? 'endpoints=' + ep : '', raw: r }; } },
                { id: 'cl-metrics', key: 'metrics', run: async () => { const r = await request(API + '/metrics'); return { ok: r.ok, extra: r.ok ? 'totalRequests=' + (r.data.totalRequests || 'N/A') : '', raw: r }; } },
                { id: 'cl-trending', key: 'trending', run: async () => { const s = performance.now(); const r = await request(API + '/trending'); const ms = (performance.now() - s).toFixed(0) + 'ms'; return { ok: r.ok, extra: r.ok ? ms + ' ' + r.data.source : '', raw: r }; } },
                { id: 'cl-trending-perf', key: 'trending_perf', run: async () => { let times = []; let sources = new Set(); for (let i = 0; i < 5; i++) { const s = performance.now(); const r = await request(API + '/trending'); const ms = performance.now() - s; if (r.ok) sources.add(r.data.source); times.push(ms); } const avg = times.length ? (times.reduce((a, b) => a + b, 0) / times.length).toFixed(0) : '0'; return { ok: times.length === 5, extra: `avg=${avg}ms src=${[...sources].join('+')}`, raw: { samples: times } }; } },
                { id: 'cl-home', key: 'home', run: async () => { const s = performance.now(); const r = await request(API + '/home'); const ms = (performance.now() - s).toFixed(0); if (!r.ok) return { ok: false, extra: '', raw: r }; const an = (r.data.announcements || []).length; const ev = (r.data.events || []).length; return { ok: true, extra: `ann=${an} ev=${ev} ${ms}ms`, raw: r }; } },
                {
                    id: 'cl-search', key: 'search', run: async () => { // 탐색적: 키워드 'test'
                        try { const s = performance.now(); const r = await request(API + '/search?q=test&limit=5'); if (!r.ok) return { ok: false, extra: 'fail', raw: r }; const ms = (performance.now() - s).toFixed(0); const cnt = (r.data.results || r.data.items || []).length; return { ok: true, extra: `cnt=${cnt} ${ms}ms`, raw: r }; } catch (e) { return { ok: false, extra: 'no-endpoint', raw: { error: e.message } }; }
                    }
                },
                { id: 'cl-boards', key: 'boards', run: async () => { const r = await request(API + '/boards'); if (!r.ok) return { ok: false, extra: '', raw: r }; const cnt = (r.data.boards || r.data || []).length; return { ok: true, extra: 'cnt=' + cnt, raw: r }; } },
                { id: 'cl-categories', key: 'categories', run: async () => { const r = await request(API + '/categories'); if (!r.ok) return { ok: false, extra: '', raw: r }; const cnt = (r.data.categories || r.data || []).length; return { ok: true, extra: 'cnt=' + cnt, raw: r }; } },
                {
                    id: 'cl-metrics-latency', key: 'metrics_latency', run: async () => {
                        try {
                            const resp = await fetch(API + '/metrics-prom');
                            const txt = await resp.text();
                            const lines = txt.split('\n');
                            let latency = null; let label = '';
                            const pick = ['client_lcp_p90', 'client_inp_p90', 'client_fcp_p90'];
                            for (const k of pick) {
                                const ln = lines.find(l => l.startsWith(k + ' '));
                                if (ln) { latency = parseFloat(ln.split(' ')[1]); label = k; break; }
                            }
                            if (!latency) {
                                const avgLn = lines.find(l => l.startsWith('http_request_duration_ms_avg '));
                                if (avgLn) { latency = parseFloat(avgLn.split(' ')[1]); label = 'http_avg'; }
                            }
                            if (latency == null) return { ok: false, extra: 'no-metrics', raw: { text: txt.slice(0, 300) } };
                            const warn = latency > 1500;
                            return { ok: true, extra: `${label}=${latency.toFixed(0)}ms` + (warn ? '⚠' : ''), raw: { latency, label } };
                        } catch (e) { return { ok: false, extra: 'fetch-error', raw: { error: e.message } }; }
                    }
                },
                { id: 'cl-chat-load', key: 'chat_load', run: async () => { try { const stats = await runChatLoadInternal(true); return { ok: true, extra: `avg=${stats.avg} p90=${stats.p90} p99=${stats.p99}`, raw: stats }; } catch (e) { return { ok: false, extra: 'err', raw: { error: e.message } }; } } },
                { id: 'cl-login', key: 'login', run: async () => { if (ACCESS_TOKEN) { return { ok: true, extra: 'existing', raw: { reused: true } }; } const lg = await fetch(API + '/auth/google', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ idToken: 'test-google:cluser:cluser@test.local' }) }); const js = await lg.json().catch(() => ({})); if (lg.ok) { ACCESS_TOKEN = js.access; return { ok: true, extra: 'test-mode', raw: js }; } return { ok: false, extra: js.error || lg.status, raw: js }; } },
                { id: 'cl-me', key: 'me', run: async () => { const r = await request(API + '/auth/me'); return { ok: r.ok, extra: r.ok ? 'ids=' + (r.data.user.identities || []).length : '', raw: r }; } },
                { id: 'cl-post', key: 'post', run: async () => { const me = await request(API + '/auth/me'); if (!me.ok) return { ok: false, extra: 'no-auth', raw: me }; const pc = await request(`${API}/boards/free/posts`, { method: 'POST', body: JSON.stringify({ title: 'CL Test ' + Date.now(), content: 'Checklist post' }) }); if (!pc.ok) return { ok: false, extra: pc.error, raw: pc }; const pid = pc.data.id; const det = await request(`${API}/posts/${pid}`); const authorOk = det.ok && det.data.author === me.data.user.display_name; return { ok: det.ok && authorOk, extra: authorOk ? 'author ok' : 'author mismatch', raw: { create: pc, detail: det } }; } },
                { id: 'cl-chat', key: 'chat', run: async () => { const chatMsg = 'cl chat ' + Date.now(); const cp = await request(API + '/chat/test/messages', { method: 'POST', body: JSON.stringify({ content: chatMsg, author: 'CLBot' }) }); const cg = await request(API + '/chat/test/messages'); const found = cg.ok && (cg.data.messages || []).some(m => m.content === chatMsg); const chatOk = cp.ok && cg.ok && found; return { ok: chatOk, extra: found ? 'ok' : 'not found', raw: { post: cp, get: cg } }; } },
                { id: 'cl-latest500', key: 'latest500', run: async () => { const comms = ['free', 'news', 'game', 'image', 'default', 'test']; let okLatest = true; let total = 0; for (const c of comms) { const r = await request(`${API}/chat/${c}/messages?limit=10`); if (!r.ok) { okLatest = false; break; } total += (r.data.messages || []).length; } return { ok: okLatest, extra: 'sum=' + total, raw: { total } }; } },
                {
                    id: 'cl-security', key: 'security', run: async () => {
                        try {
                            const resp = await fetch(API + '/health');
                            const csp = resp.headers.get('Content-Security-Policy');
                            const xcto = resp.headers.get('X-Content-Type-Options');
                            const xfo = resp.headers.get('X-Frame-Options');
                            const rp = resp.headers.get('Referrer-Policy');
                            const pp = resp.headers.get('Permissions-Policy');
                            const missing = [];
                            if (!csp) missing.push('csp');
                            if (!xcto) missing.push('xcto');
                            if (!xfo) missing.push('xfo');
                            if (!rp) missing.push('rp');
                            if (!pp) missing.push('pp');
                            const ok = missing.length === 0;
                            const extra = ok ? 'all' : ('miss:' + missing.join(','));
                            return { ok, extra, raw: { csp, xcto, xfo, rp, pp } };
                        } catch (e) { return { ok: false, extra: 'fetch error', raw: { error: e.message } }; }
                    }
                }
            ];
        }
        function percentile(arr, p) { if (!arr.length) return 0; const s = [...arr].sort((a, b) => a - b); const idx = Math.min(s.length - 1, Math.floor(p * s.length)); return s[idx]; }
        async function runChatLoadInternal(internal = false) {
            const N = parseInt(document.getElementById('chat-load-n')?.value || '30', 10);
            const C = parseInt(document.getElementById('chat-load-c')?.value || '5', 10);
            const delays = [];
            let sent = 0;
            async function worker() {
                while (true) {
                    const i = sent++; if (i >= N) break;
                    const msg = 'load ' + i + ' ' + Math.random().toString(36).slice(2, 6);
                    const s = performance.now();
                    await request(`${API}/chat/test/messages`, { method: 'POST', body: JSON.stringify({ content: msg, author: 'LoadBot' }) });
                    delays.push(performance.now() - s);
                }
            }
            const workers = []; for (let i = 0; i < C; i++) workers.push(worker());
            await Promise.all(workers);
            const avg = delays.length ? (delays.reduce((a, b) => a + b, 0) / delays.length) : 0;
            const p90 = percentile(delays, 0.90).toFixed(0);
            const p99 = percentile(delays, 0.99).toFixed(0);
            if (!internal) {
                show('chat-load-result', `✅ N=${N} C=${C} avg=${avg.toFixed(1)}ms p90=${p90} p99=${p99}`, 'success');
            }
            return { N, C, count: delays.length, avg: avg.toFixed(1), p90, p99 };
        }
        async function runChatLoad() { show('chat-load-result', '⏳ 실행 중...', 'info'); try { await runChatLoadInternal(false); } catch (e) { show('chat-load-result', '❌ 실패 ' + e.message, 'error'); } }
        async function runChecklist() {
            logChecklist('체크리스트 시작');
            const TESTS = buildTests();
            const failList = [];
            const startAll = performance.now();
            for (const t of TESTS) {
                const start = performance.now();
                let res;
                try { res = await t.run(); } catch (e) { res = { ok: false, extra: 'exception', raw: { error: e.message } }; }
                const ms = (performance.now() - start).toFixed(0);
                CHECK_RESULTS[t.key] = { ...res, ms: Number(ms) };
                mark(t.id, res.ok, (res.extra ? res.extra + ' ' : '') + ms + 'ms');
                logChecklist(`${t.key}: ${res.ok ? 'ok' : 'fail'} (${ms}ms)` + (res.extra ? ' ' + res.extra : ''), res.ok ? 'info' : 'error');
                if (!res.ok) failList.push(t.key);
            }
            const took = (performance.now() - startAll).toFixed(0);
            const passed = TESTS.length - failList.length;
            CHECK_RESULTS['summary'] = { passed, total: TESTS.length, failed: failList, ms: Number(took) };
            const summary = `=== 요약 ===\n총 ${TESTS.length}개 중 ${passed}개 성공 (${took}ms)` + (failList.length ? `\n실패: ${failList.join(', ')}` : '\n모두 성공 ✅');
            logChecklist(summary, failList.length ? 'error' : 'success');
        }
        async function retryFailed() {
            const prev = CHECK_RESULTS['summary'];
            if (!prev || !prev.failed || !prev.failed.length) {
                logChecklist('재시도할 실패 항목 없음');
                return;
            }
            logChecklist('실패 항목 재시도: ' + prev.failed.join(', '));
            const tests = buildTests().filter(t => prev.failed.includes(t.key));
            const newFails = [];
            for (const t of tests) {
                const start = performance.now();
                let res; try { res = await t.run(); } catch (e) { res = { ok: false, extra: 'exception', raw: { error: e.message } }; }
                const ms = (performance.now() - start).toFixed(0);
                CHECK_RESULTS[t.key] = { ...res, ms: Number(ms), retried: true };
                mark(t.id, res.ok, (res.extra ? res.extra + ' ' : '') + ms + 'ms');
                logChecklist(`(재) ${t.key}: ${res.ok ? 'ok' : 'fail'} (${ms}ms)` + (res.extra ? ' ' + res.extra : ''), res.ok ? 'info' : 'error');
                if (!res.ok) newFails.push(t.key);
            }
            // 기존 실패 중 복구된 항목 반영
            const still = newFails;
            const allTests = buildTests();
            const passed = allTests.length - still.length;
            CHECK_RESULTS['summary'] = { passed, total: allTests.length, failed: still, ms: CHECK_RESULTS.summary ? CHECK_RESULTS.summary.ms : undefined, retriedAt: Date.now() };
            logChecklist(`재시도 완료. 남은 실패: ${still.length ? still.join(', ') : '없음 ✅'}`, still.length ? 'error' : 'success');
        }
        function exportChecklistJson() {
            try {
                const blob = new Blob([JSON.stringify(CHECK_RESULTS, null, 2)], { type: 'application/json' });
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                const ts = new Date().toISOString().replace(/[:.]/g, '-');
                a.download = `checklist-results-${ts}.json`;
                document.body.appendChild(a);
                a.click();
                setTimeout(() => { URL.revokeObjectURL(a.href); a.remove(); }, 500);
                logChecklist('결과 JSON export 완료');
            } catch (e) {
                logChecklist('Export 실패: ' + e.message, 'error');
            }
        }
        // file:// 로 열었는지 감지하여 경고 (checklist-log 사용)
        if (location.protocol === 'file:') {
            setTimeout(() => { const box = document.getElementById('checklist-log'); if (box && /대기 중/.test(box.textContent)) { logChecklist('⚠️ file:// 로 열림: fetch / Google 로그인 제한 가능. http://localhost 사용 권장', 'error'); } }, 200);
        }
    </script>
</body>

</html>