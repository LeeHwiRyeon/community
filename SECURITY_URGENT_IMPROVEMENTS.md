# ğŸ”´ Community Platform v1.0 - ê¸´ê¸‰ ë³´ì•ˆ ê°œì„  ìƒì„¸ ê¸°íšì„œ

**ì‘ì„±ì¼**: 2025ë…„ 11ì›” 9ì¼  
**ìµœì¢… ì—…ë°ì´íŠ¸**: 2025ë…„ 11ì›” 9ì¼  
**ìš°ì„ ìˆœìœ„**: P0 (ê¸´ê¸‰)  
**ì§„í–‰ ìƒí™©**: 50% ì™„ë£Œ (5/10 ì‘ì—…)  
**ëª©í‘œ ì™„ë£Œì¼**: 2025ë…„ 11ì›” 15ì¼ (1ì£¼ ì´ë‚´)

---

## ğŸ“‹ ëª©ì°¨
1. [ê°œì„  í•­ëª© ìš”ì•½](#1-ê°œì„ -í•­ëª©-ìš”ì•½)
2. [ì™„ë£Œëœ ì‘ì—…](#2-ì™„ë£Œëœ-ì‘ì—…)
3. [ì§„í–‰ ì˜ˆì • ì‘ì—…](#3-ì§„í–‰-ì˜ˆì •-ì‘ì—…)
4. [í…ŒìŠ¤íŠ¸ ê³„íš](#4-í…ŒìŠ¤íŠ¸-ê³„íš)
5. [ë°°í¬ ì „ëµ](#5-ë°°í¬-ì „ëµ)

---

## 1. ê°œì„  í•­ëª© ìš”ì•½

| #   | ê°œì„  í•­ëª©                       | í˜„ì¬ ìƒíƒœ     | ìœ„í—˜ë„      | ì˜ˆìƒ ì†Œìš” | ë‹´ë‹¹ì   | ìƒíƒœ |
| --- | ------------------------------- | ------------- | ----------- | --------- | -------- | ---- |
| 1   | JWT Secret í™˜ê²½ ë³€ìˆ˜ í•„ìˆ˜í™”     | âœ… ì™„ë£Œ        | ğŸ”´ ë§¤ìš° ë†’ìŒ | 1ì¼       | Backend  | âœ…    |
| 2   | í† í° ë¸”ë™ë¦¬ìŠ¤íŠ¸ êµ¬í˜„            | âœ… ì™„ë£Œ        | ğŸŸ¡ ë†’ìŒ      | 3ì¼       | Backend  | âœ…    |
| 3   | ë©”ì‹œì§€ ì•”í˜¸í™” ê°•í™” (AES-GCM)    | âœ… ì™„ë£Œ        | ğŸŸ¡ ë†’ìŒ      | 3ì¼       | Frontend | âœ…    |
| 4   | CSRF í† í° ì™„ì „ êµ¬í˜„             | âœ… ë°±ì—”ë“œ ì™„ë£Œ | ğŸŸ¡ ì¤‘ê°„      | 2ì¼       | Backend  | âœ…    |
| 5   | ì•”í˜¸í™” UI/UX í†µí•©               | âœ… ì™„ë£Œ        | ğŸŸ¢ ë‚®ìŒ      | 1ì¼       | Frontend | âœ…    |
| 6   | í† í° ë¸”ë™ë¦¬ìŠ¤íŠ¸ í”„ë¡ íŠ¸ì—”ë“œ í†µí•© | â³ ëŒ€ê¸°ì¤‘      | ğŸŸ¡ ì¤‘ê°„      | 1ì¼       | Frontend | â³    |
| 7   | CSRF í† í° í”„ë¡ íŠ¸ì—”ë“œ í†µí•©       | â³ ëŒ€ê¸°ì¤‘      | ğŸŸ¡ ì¤‘ê°„      | 1ì¼       | Frontend | â³    |
| 8   | í†µí•© í…ŒìŠ¤íŠ¸ ë° E2E ê²€ì¦         | â³ ëŒ€ê¸°ì¤‘      | ğŸŸ¢ ë‚®ìŒ      | 1ì¼       | All      | â³    |
| 9   | ë³´ì•ˆ ë¬¸ì„œ ì—…ë°ì´íŠ¸              | â³ ëŒ€ê¸°ì¤‘      | ğŸŸ¢ ë‚®ìŒ      | 1ì¼       | All      | â³    |
| 10  | í”„ë¡œë•ì…˜ ë°°í¬ ì¤€ë¹„ ë° ìµœì¢… ê²€ì¦ | â³ ëŒ€ê¸°ì¤‘      | ğŸŸ¡ ì¤‘ê°„      | 1ì¼       | All      | â³    |

**ì´ ì˜ˆìƒ ì†Œìš” ì‹œê°„**: 10ì¼ (ì•½ 2ì£¼)  
**ì™„ë£Œëœ ì‹œê°„**: 5ì¼ (50%)  
**ë‚¨ì€ ì‹œê°„**: 5ì¼ (50%)

---

## 2. ì™„ë£Œëœ ì‘ì—…

### âœ… 2.1 JWT Secret í™˜ê²½ ë³€ìˆ˜ í•„ìˆ˜í™” (ì™„ë£Œ)
## 2. ì™„ë£Œëœ ì‘ì—…

### âœ… 2.1 JWT Secret í™˜ê²½ ë³€ìˆ˜ í•„ìˆ˜í™” (ì™„ë£Œ)

**ì™„ë£Œì¼**: 2025ë…„ 11ì›” 9ì¼  
**ì†Œìš” ì‹œê°„**: 1ì¼  
**ë‹´ë‹¹**: Backend ê°œë°œì

#### êµ¬í˜„ ë‚´ìš©

**1. jwt.js í™˜ê²½ ë³€ìˆ˜ í•„ìˆ˜í™”**
```javascript
// server-backend/src/auth/jwt.js
const SECRET = process.env.JWT_SECRET;

if (!SECRET) {
    console.error('âŒ FATAL: JWT_SECRET environment variable is not set!');
    console.error('Please set JWT_SECRET in your .env file');
    console.error('Generate: node scripts/generate-jwt-secret.js');
    console.error('Example: JWT_SECRET=$(openssl rand -base64 64)');
    process.exit(1);
}

if (SECRET.length < 32) {
    console.error('âŒ FATAL: JWT_SECRET must be at least 32 characters long');
    console.error(`Current length: ${SECRET.length} characters`);
    process.exit(1);
}

console.log('âœ… JWT_SECRET validated successfully');
```

**2. startup-checks.js ê²€ì¦ ì‹œìŠ¤í…œ**
```javascript
// server-backend/src/startup-checks.js
const requiredEnvVars = [
    { name: 'JWT_SECRET', value: process.env.JWT_SECRET, minLength: 32 },
    { name: 'DB_HOST', value: process.env.DB_HOST },
    { name: 'DB_USER', value: process.env.DB_USER },
    { name: 'DB_PASSWORD', value: process.env.DB_PASSWORD },
    { name: 'DB_NAME', value: process.env.DB_NAME }
];

function validateEnvironment() {
    let hasError = false;
    
    for (const envVar of requiredEnvVars) {
        if (!envVar.value) {
            console.error(`âŒ Missing required environment variable: ${envVar.name}`);
            hasError = true;
        } else if (envVar.minLength && envVar.value.length < envVar.minLength) {
            console.error(`âŒ ${envVar.name} must be at least ${envVar.minLength} characters`);
            hasError = true;
        }
    }
    
    if (hasError) {
        process.exit(1);
    }
    
    console.log('âœ… All environment variables validated');
}

module.exports = { validateEnvironment };
```

**3. generate-jwt-secret.js ìŠ¤í¬ë¦½íŠ¸**
```javascript
// server-backend/scripts/generate-jwt-secret.js
const crypto = require('crypto');

function generateJWTSecret() {
    const secret = crypto.randomBytes(64).toString('base64');
    
    console.log('='.repeat(80));
    console.log('JWT Secret Generator');
    console.log('='.repeat(80));
    console.log('\nGenerated JWT Secret (64 bytes, base64):');
    console.log('\x1b[32m%s\x1b[0m', secret);
    console.log('\nAdd this to your .env file:');
    console.log(`JWT_SECRET=${secret}`);
    console.log('\nSecurity Notes:');
    console.log('- Keep this secret secure and never commit to version control');
    console.log('- Use different secrets for dev, staging, and production');
    console.log('- Rotate secrets periodically (recommended: every 90 days)');
    console.log('='.repeat(80));
}

generateJWTSecret();
```

#### ë³´ì•ˆ ê°œì„  íš¨ê³¼
- âœ… í™˜ê²½ ë³€ìˆ˜ ë¯¸ì„¤ì • ì‹œ ì„œë²„ ì‹œì‘ ì‹¤íŒ¨
- âœ… Secret ê°•ë„ ê²€ì¦ (ìµœì†Œ 32ì)
- âœ… ì†ŒìŠ¤ ì½”ë“œì—ì„œ ê¸°ë³¸ê°’ ì™„ì „ ì œê±°
- âœ… ê°œë°œ/ìŠ¤í…Œì´ì§•/í”„ë¡œë•ì…˜ í™˜ê²½ë³„ Secret ë¶„ë¦¬ ê°€ëŠ¥
- âœ… Secret ìƒì„± ìë™í™”

---

### âœ… 2.2 í† í° ë¸”ë™ë¦¬ìŠ¤íŠ¸ êµ¬í˜„ (ì™„ë£Œ)

**ì™„ë£Œì¼**: 2025ë…„ 11ì›” 9ì¼  
**ì†Œìš” ì‹œê°„**: 3ì¼  
**ë‹´ë‹¹**: Backend ê°œë°œì

#### êµ¬í˜„ ë‚´ìš©

**1. token-blacklist.js ì„œë¹„ìŠ¤ (367 lines)**
```javascript
// server-backend/src/services/token-blacklist.js

// Access Token ë¸”ë™ë¦¬ìŠ¤íŠ¸ ì¶”ê°€
export async function blacklistAccessToken(jti, userId, reason = 'logout', ttlSec = 900) {
    const data = {
        userId,
        reason,
        exp: Math.floor(Date.now() / 1000) + ttlSec,
        blacklistedAt: new Date().toISOString()
    };

    if (isRedisEnabled()) {
        const redis = getRedis();
        const key = `blacklist:access:${jti}`;
        await redis.setex(key, ttlSec, JSON.stringify(data));
        console.log(`âœ… Access token blacklisted (Redis): ${jti}`);
    } else {
        inMemoryBlacklist.set(`access:${jti}`, data);
        setTimeout(() => inMemoryBlacklist.delete(`access:${jti}`), ttlSec * 1000);
    }
}

// Refresh Token ë¸”ë™ë¦¬ìŠ¤íŠ¸ ì¶”ê°€
export async function blacklistRefreshToken(jti, userId, reason = 'logout', ttlSec = 1209600) {
    // Similar implementation for refresh tokens
}

// ë¸”ë™ë¦¬ìŠ¤íŠ¸ í™•ì¸
export async function isTokenBlacklisted(jti, type = 'access') {
    if (isRedisEnabled()) {
        const redis = getRedis();
        const key = `blacklist:${type}:${jti}`;
        const result = await redis.get(key);
        return result !== null;
    } else {
        return inMemoryBlacklist.has(`${type}:${jti}`);
    }
}
```

**2. JWT ê²€ì¦ ë¯¸ë“¤ì›¨ì–´ í†µí•©**
```javascript
// server-backend/src/middleware/security.js

const { isTokenBlacklisted } = require('../services/token-blacklist');

export const authenticateJWT = async (req, res, next) => {
    try {
        const token = req.headers.authorization?.split(' ')[1];
        
        if (!token) {
            return res.status(401).json({ error: 'No token provided' });
        }

        const decoded = jwt.verify(token, SECURITY_CONFIG.JWT_SECRET);
        
        // ë¸”ë™ë¦¬ìŠ¤íŠ¸ í™•ì¸
        if (decoded.jti && await isTokenBlacklisted(decoded.jti, 'access')) {
            return res.status(401).json({ 
                error: 'Token has been revoked',
                code: 'TOKEN_REVOKED'
            });
        }

        req.user = decoded;
        next();
    } catch (error) {
        return res.status(401).json({ error: 'Invalid token' });
    }
};
```

#### ì£¼ìš” ê¸°ëŠ¥
- âœ… Access Token ë¸”ë™ë¦¬ìŠ¤íŠ¸ ê´€ë¦¬
- âœ… Refresh Token ë¸”ë™ë¦¬ìŠ¤íŠ¸ ê´€ë¦¬
- âœ… Redis ìš°ì„  ì‚¬ìš©, In-memory fallback
- âœ… JTI(JWT ID) ê¸°ë°˜ í† í° ì¶”ì 
- âœ… TTL ìë™ ê´€ë¦¬ (ë§Œë£Œ ì‹œ ìë™ ì‚­ì œ)
- âœ… ë¡œê·¸ì•„ì›ƒ ì‹œ ìë™ ë¸”ë™ë¦¬ìŠ¤íŠ¸ ë“±ë¡
- âœ… ê´€ë¦¬ì ê°•ì œ ë¡œê·¸ì•„ì›ƒ ê¸°ëŠ¥

---

### âœ… 2.3 ë©”ì‹œì§€ ì•”í˜¸í™” ê°•í™” (AES-GCM) (ì™„ë£Œ)

**ì™„ë£Œì¼**: 2025ë…„ 11ì›” 9ì¼  
**ì†Œìš” ì‹œê°„**: 3ì¼  
**ë‹´ë‹¹**: Frontend ê°œë°œì

#### êµ¬í˜„ ë‚´ìš©

**1. MessageEncryptionV2.ts (AES-256-GCM)**
```typescript
// frontend/src/utils/MessageEncryptionV2.ts

export class MessageEncryptionV2 {
    private static readonly ALGORITHM = 'AES-GCM';
    private static readonly KEY_LENGTH = 256;
    private static readonly IV_LENGTH = 12; // 96 bits for GCM
    private static readonly TAG_LENGTH = 128; // 128 bits authentication tag

    // ë©”ì‹œì§€ ì•”í˜¸í™”
    static async encrypt(plaintext: string, roomKey: string): Promise<EncryptedMessage> {
        const encoder = new TextEncoder();
        const data = encoder.encode(plaintext);
        
        // ëœë¤ IV ìƒì„±
        const iv = crypto.getRandomValues(new Uint8Array(this.IV_LENGTH));
        
        // CryptoKey ìƒì„±
        const key = await this.deriveKey(roomKey);
        
        // AES-256-GCM ì•”í˜¸í™”
        const ciphertext = await crypto.subtle.encrypt(
            {
                name: 'AES-GCM',
                iv: iv,
                tagLength: this.TAG_LENGTH
            },
            key,
            data
        );
        
        return {
            version: 'v2',
            algorithm: 'AES-256-GCM',
            ciphertext: this.arrayBufferToBase64(ciphertext),
            iv: this.arrayBufferToBase64(iv),
            timestamp: Date.now()
        };
    }
    
    // ë©”ì‹œì§€ ë³µí˜¸í™”
    static async decrypt(encryptedMessage: EncryptedMessage, roomKey: string): Promise<string> {
        const key = await this.deriveKey(roomKey);
        const iv = this.base64ToArrayBuffer(encryptedMessage.iv);
        const ciphertext = this.base64ToArrayBuffer(encryptedMessage.ciphertext);
        
        const plaintext = await crypto.subtle.decrypt(
            {
                name: 'AES-GCM',
                iv: iv,
                tagLength: this.TAG_LENGTH
            },
            key,
            ciphertext
        );
        
        const decoder = new TextDecoder();
        return decoder.decode(plaintext);
    }
}
```

**2. KeyExchange.ts (ECDH P-256)**
```typescript
// frontend/src/utils/KeyExchange.ts

export class KeyExchange {
    private static readonly ALGORITHM = 'ECDH';
    private static readonly NAMED_CURVE = 'P-256';

    // í‚¤ í˜ì–´ ìƒì„±
    static async generateKeyPair(): Promise<CryptoKeyPair> {
        return await crypto.subtle.generateKey(
            {
                name: this.ALGORITHM,
                namedCurve: this.NAMED_CURVE
            },
            true,
            ['deriveKey', 'deriveBits']
        );
    }
    
    // ê³µìœ  ë¹„ë°€ ìƒì„±
    static async deriveSharedSecret(
        privateKey: CryptoKey,
        publicKey: CryptoKey
    ): Promise<CryptoKey> {
        return await crypto.subtle.deriveKey(
            {
                name: this.ALGORITHM,
                public: publicKey
            },
            privateKey,
            {
                name: 'AES-GCM',
                length: 256
            },
            true,
            ['encrypt', 'decrypt']
        );
    }
}
```

**3. v1â†’v2 ë§ˆì´ê·¸ë ˆì´ì…˜ ì§€ì›**
```typescript
// frontend/src/services/EncryptedChatService.ts

export function migrateMessage(message: any): EncryptedMessage {
    if (message.version === 'v2') {
        return message; // Already v2
    }
    
    // Migrate from v1 (CBC) to v2 (GCM)
    console.log('Migrating message from v1 to v2');
    
    // Decrypt v1 message
    const plaintext = MessageEncryption.decrypt(message);
    
    // Re-encrypt with v2
    return MessageEncryptionV2.encrypt(plaintext, getRoomKey());
}
```

#### ë³´ì•ˆ ê°œì„  íš¨ê³¼
- âœ… AES-CBC â†’ AES-GCM (ì¸ì¦ ì•”í˜¸í™”)
- âœ… CryptoJS â†’ Web Crypto API (ë¸Œë¼ìš°ì € ë„¤ì´í‹°ë¸Œ)
- âœ… ECDH P-256 í‚¤ êµí™˜ í”„ë¡œí† ì½œ
- âœ… ì¸ì¦ íƒœê·¸ë¥¼ í†µí•œ ë¬´ê²°ì„± ê²€ì¦
- âœ… v1/v2 í˜¸í™˜ì„± ìœ ì§€
- âœ… ì„±ëŠ¥ í–¥ìƒ (ë„¤ì´í‹°ë¸Œ ì•”í˜¸í™”)

---

### âœ… 2.4 CSRF í† í° ì™„ì „ êµ¬í˜„ (ë°±ì—”ë“œ ì™„ë£Œ)

**ì™„ë£Œì¼**: 2025ë…„ 11ì›” 9ì¼  
**ì†Œìš” ì‹œê°„**: 2ì¼  
**ë‹´ë‹¹**: Backend ê°œë°œì

#### êµ¬í˜„ ë‚´ìš©

**1. csrf.js ìœ í‹¸ë¦¬í‹°**
```javascript
// server-backend/src/utils/csrf.js

const crypto = require('crypto');

// CSRF í† í° ìƒì„±
function generateCSRFToken(req, res) {
    const token = crypto.randomBytes(32).toString('base64');
    
    // ì„¸ì…˜ì— í† í° ì €ì¥
    if (req.session) {
        req.session.csrfToken = token;
    }
    
    // ì¿ í‚¤ì—ë„ í† í° ì €ì¥ (Double Submit Cookie)
    res.cookie('XSRF-TOKEN', token, {
        httpOnly: false, // JSì—ì„œ ì½ì„ ìˆ˜ ìˆì–´ì•¼ í•¨
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'strict',
        maxAge: 3600000 // 1 hour
    });
    
    return token;
}

// CSRF í† í° ê²€ì¦
function validateCSRFToken(req) {
    const sessionToken = req.session?.csrfToken;
    const headerToken = req.headers['x-csrf-token'];
    const cookieToken = req.cookies['XSRF-TOKEN'];
    
    if (!sessionToken || !headerToken) {
        return false;
    }
    
    // Double Submit Cookie ê²€ì¦
    return sessionToken === headerToken && sessionToken === cookieToken;
}

module.exports = { generateCSRFToken, validateCSRFToken };
```

**2. csrf.js ë¯¸ë“¤ì›¨ì–´**
```javascript
// server-backend/src/middleware/csrf.js

const { validateCSRFToken } = require('../utils/csrf');

function csrfProtection(options = {}) {
    const { methods = ['POST', 'PUT', 'DELETE', 'PATCH'] } = options;
    
    return (req, res, next) => {
        // Safe methodsëŠ” CSRF ê²€ì¦ ìŠ¤í‚µ
        if (!methods.includes(req.method)) {
            return next();
        }
        
        // CSRF í† í° ê²€ì¦
        if (!validateCSRFToken(req)) {
            return res.status(403).json({
                error: 'CSRF token validation failed',
                code: 'CSRF_INVALID'
            });
        }
        
        next();
    };
}

module.exports = { csrfProtection };
```

**3. í†µí•© í…ŒìŠ¤íŠ¸**
```javascript
// server-backend/tests/csrf-integration.test.js

describe('CSRF Token System', () => {
    it('should generate CSRF token', async () => {
        const res = await request(app)
            .get('/api/auth/csrf-token')
            .expect(200);
        
        expect(res.body.data.csrfToken).toBeDefined();
    });
    
    it('should reject request without CSRF token', async () => {
        await request(app)
            .post('/api/test/protected')
            .send({ data: 'test' })
            .expect(403);
    });
    
    it('should accept request with valid CSRF token', async () => {
        const tokenRes = await request(app).get('/api/auth/csrf-token');
        const csrfToken = tokenRes.body.data.csrfToken;
        
        await request(app)
            .post('/api/test/protected')
            .set('X-CSRF-Token', csrfToken)
            .set('Cookie', tokenRes.headers['set-cookie'])
            .send({ data: 'test' })
            .expect(200);
    });
});
```

#### ë³´ì•ˆ ê°œì„  íš¨ê³¼
- âœ… Double Submit Cookie íŒ¨í„´
- âœ… ì„¸ì…˜ + ì¿ í‚¤ ì´ì¤‘ ê²€ì¦
- âœ… Safe methods (GET, HEAD, OPTIONS) ìë™ ì œì™¸
- âœ… í† í° ìë™ ë§Œë£Œ (1ì‹œê°„)
- âœ… SameSite=strict ì¿ í‚¤ ì„¤ì •
- âœ… í”„ë¡œë•ì…˜ í™˜ê²½ì—ì„œ Secure ì¿ í‚¤

---

### âœ… 2.5 ì•”í˜¸í™” UI/UX í†µí•© (ì™„ë£Œ)

**ì™„ë£Œì¼**: 2025ë…„ 11ì›” 9ì¼  
**ì†Œìš” ì‹œê°„**: 1ì¼  
**ë‹´ë‹¹**: Frontend ê°œë°œì

#### êµ¬í˜„ ë‚´ìš©

**1. ChatSystem.tsx ì•”í˜¸í™” í† ê¸€**
```typescript
// frontend/src/components/ChatSystem.tsx

const [isEncryptionEnabled, setIsEncryptionEnabled] = useState(false);
const [encryptionDialogOpen, setEncryptionDialogOpen] = useState(false);
const { encryptMessage, decryptMessage, isEncryptionEnabled: cryptoEnabled } = useMessageEncryption(currentRoom);

// ì•”í˜¸í™” í† ê¸€ ë²„íŠ¼
<IconButton 
    onClick={handleEncryptionToggle}
    color={isEncryptionEnabled ? 'success' : 'default'}
>
    {isEncryptionEnabled ? <Lock /> : <LockOpen />}
</IconButton>

// ì•”í˜¸í™” ìƒíƒœ í‘œì‹œ
{isEncryptionEnabled && (
    <Alert severity="success" icon={<Security />}>
        ì—”ë“œíˆ¬ì—”ë“œ ì•”í˜¸í™” í™œì„±í™”ë¨
    </Alert>
)}
```

**2. í‚¤ êµí™˜ ë‹¤ì´ì–¼ë¡œê·¸**
```typescript
<Dialog open={encryptionDialogOpen}>
    <DialogTitle>
        <VpnKey /> ì•”í˜¸í™” í‚¤ êµí™˜
    </DialogTitle>
    <DialogContent>
        {isKeyExchanging ? (
            <>
                <CircularProgress size={60} />
                <LinearProgress 
                    variant="determinate" 
                    value={keyExchangeProgress} 
                />
                <Typography>í‚¤ êµí™˜ ì¤‘... {keyExchangeProgress}%</Typography>
            </>
        ) : (
            <>
                <Security color="success" />
                <Typography>AES-256-GCM ì•”í˜¸í™” ì¤€ë¹„ ì™„ë£Œ</Typography>
            </>
        )}
    </DialogContent>
</Dialog>
```

**3. ì•”í˜¸í™”ëœ ë©”ì‹œì§€ í‘œì‹œ**
```typescript
// ë©”ì‹œì§€ ë Œë”ë§
{messages.map((msg) => (
    <Box key={msg.id}>
        {msg.isEncrypted && <Lock fontSize="small" />}
        <Typography>
            {msg.isEncrypted 
                ? decryptMessageContent(msg) 
                : msg.content
            }
        </Typography>
        {msg.isEncrypted && (
            <Chip label="ì•”í˜¸í™”ë¨" size="small" color="success" />
        )}
    </Box>
))}
```

#### UI/UX ê°œì„  íš¨ê³¼
- âœ… ì›í´ë¦­ ì•”í˜¸í™” í† ê¸€
- âœ… ì‹œê°ì  ì•”í˜¸í™” ìƒíƒœ í‘œì‹œ
- âœ… í‚¤ êµí™˜ ì§„í–‰ ìƒí™© í‘œì‹œ
- âœ… ì•”í˜¸í™”ëœ ë©”ì‹œì§€ ìë™ ë³µí˜¸í™”
- âœ… ì—ëŸ¬ ì²˜ë¦¬ ë° ì‚¬ìš©ì í”¼ë“œë°±
- âœ… Material-UI ë””ìì¸ í†µí•©

---

## 3. ì§„í–‰ ì˜ˆì • ì‘ì—…
    console.log(`\nSecret Strength: ${entropy.toFixed(2)} bits of entropy`);
    
    if (entropy < 256) {
        console.warn('âš ï¸ Warning: Secret entropy is below recommended 256 bits');
    } else {
        console.log('âœ… Secret meets security requirements');
    }
}

function calculateEntropy(str) {
    const freq = {};
    for (let char of str) {
        freq[char] = (freq[char] || 0) + 1;
    }
    
    let entropy = 0;
    const len = str.length;
    
    for (let char in freq) {
        const p = freq[char] / len;
        entropy -= p * Math.log2(p);
    }
    
    return entropy * len;
}

generateJWTSecret();
```

**Step 4: CI/CD íŒŒì´í”„ë¼ì¸ í†µí•©**
```yaml
# .github/workflows/security-check.yml
name: Security Check

on: [push, pull_request]

jobs:
  check-secrets:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Check for hardcoded secrets
        run: |
          if grep -r "JWT_SECRET.*=" --include="*.js" --exclude-dir=node_modules .; then
            echo "âŒ Hardcoded JWT_SECRET found!"
            exit 1
          fi
          echo "âœ… No hardcoded secrets found"
      
      - name: Verify .env.example exists
        run: |
          if [ ! -f server-backend/.env.example ]; then
            echo "âŒ .env.example not found!"
            exit 1
          fi
```

**Step 5: ì„œë²„ ì‹œì‘ ì‹œ Secret ê²€ì¦**
```javascript
// server-backend/src/startup-checks.js
function validateSecurityConfig() {
    const checks = [
        {
            name: 'JWT_SECRET',
            value: process.env.JWT_SECRET,
            minLength: 32,
            required: true
        },
        {
            name: 'SESSION_SECRET',
            value: process.env.SESSION_SECRET,
            minLength: 32,
            required: false
        }
    ];
    
    let hasErrors = false;
    
    checks.forEach(check => {
        if (check.required && !check.value) {
            console.error(`âŒ ${check.name} is required but not set`);
            hasErrors = true;
        }
        
        if (check.value && check.value.length < check.minLength) {
            console.error(`âŒ ${check.name} must be at least ${check.minLength} characters`);
            hasErrors = true;
        }
    });
    
    if (hasErrors) {
        console.error('\nğŸ”´ Security configuration errors detected. Server will not start.');
        process.exit(1);
    }
    
    console.log('âœ… Security configuration validated');
}

module.exports = { validateSecurityConfig };
```

#### êµ¬í˜„ ì²´í¬ë¦¬ìŠ¤íŠ¸
- [ ] `jwt.js`ì—ì„œ ê¸°ë³¸ê°’ ì œê±° ë° í™˜ê²½ ë³€ìˆ˜ í•„ìˆ˜í™”
- [ ] Secret ê°•ë„ ê²€ì¦ ë¡œì§ ì¶”ê°€
- [ ] `.env.example` íŒŒì¼ ìƒì„±
- [ ] `generate-jwt-secret.js` ìŠ¤í¬ë¦½íŠ¸ ì‘ì„±
- [ ] `startup-checks.js` ëª¨ë“ˆ ì‘ì„±
- [ ] CI/CD íŒŒì´í”„ë¼ì¸ì— Secret ê²€ì¦ ì¶”ê°€
- [ ] ê¸°ì¡´ ë°°í¬ í™˜ê²½ì˜ Secret ì¬ìƒì„± ë° ì—…ë°ì´íŠ¸
- [ ] ë¬¸ì„œ ì—…ë°ì´íŠ¸ (README.md, SECURITY.md)

#### í…ŒìŠ¤íŠ¸ ì‹œë‚˜ë¦¬ì˜¤
1. **í™˜ê²½ ë³€ìˆ˜ ì—†ì´ ì„œë²„ ì‹œì‘** â†’ âŒ ì¦‰ì‹œ ì¢…ë£Œ
2. **ì§§ì€ Secret ì„¤ì •** (< 32ì) â†’ âŒ ì¦‰ì‹œ ì¢…ë£Œ
3. **ìœ íš¨í•œ Secret ì„¤ì •** â†’ âœ… ì •ìƒ ì‹œì‘
4. **CI/CDì—ì„œ í•˜ë“œì½”ë”©ëœ Secret ê°ì§€** â†’ âŒ ë¹Œë“œ ì‹¤íŒ¨

---

### ğŸŸ¡ 2.2 í† í° ë¸”ë™ë¦¬ìŠ¤íŠ¸ êµ¬í˜„

#### í˜„ì¬ ë¬¸ì œì 
- âœ— ê°•ì œ ë¡œê·¸ì•„ì›ƒ ë¶ˆê°€ëŠ¥ (Access Tokenì´ ë§Œë£Œë  ë•Œê¹Œì§€ ìœ íš¨)
- âœ— íƒˆì·¨ëœ í† í° ë¬´íš¨í™” ë¶ˆê°€ëŠ¥
- âœ— ì‚¬ìš©ìê°€ ë¡œê·¸ì•„ì›ƒí•´ë„ í† í°ì€ ì—¬ì „íˆ ìœ íš¨

#### ê°œì„  ë°©ì•ˆ

**Step 1: Redis ë¸”ë™ë¦¬ìŠ¤íŠ¸ ìŠ¤í‚¤ë§ˆ ì„¤ê³„**
```
Key: blacklist:access:{jti}
Value: { userId, reason, exp }
TTL: Access Token ë§Œë£Œ ì‹œê°„ (15ë¶„)

Key: blacklist:refresh:{jti}
Value: { userId, reason, exp }
TTL: Refresh Token ë§Œë£Œ ì‹œê°„ (14ì¼)
```

**Step 2: ë¸”ë™ë¦¬ìŠ¤íŠ¸ ì„œë¹„ìŠ¤ êµ¬í˜„**
```javascript
// server-backend/src/services/token-blacklist.js

import { isRedisEnabled, getRedis } from '../redis.js';

const inMemoryBlacklist = new Map(); // Redis ë¯¸ì‚¬ìš© ì‹œ fallback

/**
 * Access Tokenì„ ë¸”ë™ë¦¬ìŠ¤íŠ¸ì— ì¶”ê°€
 */
export async function blacklistAccessToken(jti, userId, reason = 'logout', ttlSec = 900) {
    const data = {
        userId,
        reason,
        exp: Math.floor(Date.now() / 1000) + ttlSec
    };
    
    if (isRedisEnabled()) {
        const redis = getRedis();
        await redis.setex(`blacklist:access:${jti}`, ttlSec, JSON.stringify(data));
        console.log(`âœ… Access token ${jti} blacklisted (Redis)`);
    } else {
        inMemoryBlacklist.set(`access:${jti}`, data);
        
        // TTL ì—ë®¬ë ˆì´ì…˜
        setTimeout(() => {
            inMemoryBlacklist.delete(`access:${jti}`);
        }, ttlSec * 1000);
        
        console.log(`âœ… Access token ${jti} blacklisted (In-memory)`);
    }
}

/**
 * Refresh Tokenì„ ë¸”ë™ë¦¬ìŠ¤íŠ¸ì— ì¶”ê°€
 */
export async function blacklistRefreshToken(jti, userId, reason = 'logout', ttlSec = 1209600) {
    const data = {
        userId,
        reason,
        exp: Math.floor(Date.now() / 1000) + ttlSec
    };
    
    if (isRedisEnabled()) {
        const redis = getRedis();
        await redis.setex(`blacklist:refresh:${jti}`, ttlSec, JSON.stringify(data));
        console.log(`âœ… Refresh token ${jti} blacklisted (Redis)`);
    } else {
        inMemoryBlacklist.set(`refresh:${jti}`, data);
        
        setTimeout(() => {
            inMemoryBlacklist.delete(`refresh:${jti}`);
        }, ttlSec * 1000);
        
        console.log(`âœ… Refresh token ${jti} blacklisted (In-memory)`);
    }
}

/**
 * Access Tokenì´ ë¸”ë™ë¦¬ìŠ¤íŠ¸ì— ìˆëŠ”ì§€ í™•ì¸
 */
export async function isAccessTokenBlacklisted(jti) {
    if (isRedisEnabled()) {
        const redis = getRedis();
        const data = await redis.get(`blacklist:access:${jti}`);
        return !!data;
    } else {
        const data = inMemoryBlacklist.get(`access:${jti}`);
        if (!data) return false;
        
        // ë§Œë£Œ í™•ì¸
        const now = Math.floor(Date.now() / 1000);
        if (now >= data.exp) {
            inMemoryBlacklist.delete(`access:${jti}`);
            return false;
        }
        
        return true;
    }
}

/**
 * Refresh Tokenì´ ë¸”ë™ë¦¬ìŠ¤íŠ¸ì— ìˆëŠ”ì§€ í™•ì¸
 */
export async function isRefreshTokenBlacklisted(jti) {
    if (isRedisEnabled()) {
        const redis = getRedis();
        const data = await redis.get(`blacklist:refresh:${jti}`);
        return !!data;
    } else {
        const data = inMemoryBlacklist.get(`refresh:${jti}`);
        if (!data) return false;
        
        const now = Math.floor(Date.now() / 1000);
        if (now >= data.exp) {
            inMemoryBlacklist.delete(`refresh:${jti}`);
            return false;
        }
        
        return true;
    }
}

/**
 * ì‚¬ìš©ìì˜ ëª¨ë“  í† í° ë¬´íš¨í™” (ë³´ì•ˆ ì´ë²¤íŠ¸)
 */
export async function blacklistAllUserTokens(userId, reason = 'security_event') {
    // ì‚¬ìš©ìì˜ í™œì„± ì„¸ì…˜ ì¶”ì  í•„ìš” (ë³„ë„ êµ¬í˜„)
    console.warn(`âš ï¸ Blacklisting all tokens for user ${userId}: ${reason}`);
    // TODO: ì‚¬ìš©ìë³„ í™œì„± í† í° ì¶”ì  ì‹œìŠ¤í…œ êµ¬í˜„
}
```

**Step 3: JWT ê²€ì¦ ë¯¸ë“¤ì›¨ì–´ ìˆ˜ì •**
```javascript
// server-backend/src/auth/jwt.js

import { isAccessTokenBlacklisted, isRefreshTokenBlacklisted } from '../services/token-blacklist.js';

export function verifyToken(token, expectedTyp = 'access') {
    try {
        const payload = jwt.verify(token, SECRET, {
            algorithms: ['HS256'],
            issuer: process.env.JWT_ISSUER || 'community-platform',
            audience: process.env.JWT_AUDIENCE || 'community-platform-users'
        });
        
        if (expectedTyp && payload.typ !== expectedTyp) return null;
        
        return payload;
    } catch (error) {
        console.warn('JWT verification failed:', error.message);
        return null;
    }
}

// ë¸”ë™ë¦¬ìŠ¤íŠ¸ ì²´í¬ ë¯¸ë“¤ì›¨ì–´
export function buildAuthMiddleware(dbQuery) {
    return async (req, res, next) => {
        const authHeader = req.headers.authorization;
        if (!authHeader || !authHeader.startsWith('Bearer ')) {
            return res.status(401).json({ error: 'Missing or invalid token' });
        }
        
        const token = authHeader.substring(7);
        const payload = verifyToken(token, 'access');
        
        if (!payload) {
            return res.status(401).json({ error: 'Invalid or expired token' });
        }
        
        // ë¸”ë™ë¦¬ìŠ¤íŠ¸ ì²´í¬ (JTIê°€ ìˆëŠ” ê²½ìš°)
        if (payload.jti) {
            const isBlacklisted = await isAccessTokenBlacklisted(payload.jti);
            if (isBlacklisted) {
                console.warn(`âš ï¸ Blacklisted token attempt: ${payload.jti}`);
                return res.status(401).json({ error: 'Token has been revoked' });
            }
        }
        
        // ì‚¬ìš©ì ì •ë³´ ì¡°íšŒ
        const [rows] = await dbQuery('SELECT id, role FROM users WHERE id = ? AND deleted = 0', [payload.sub]);
        if (!rows || rows.length === 0) {
            return res.status(401).json({ error: 'User not found' });
        }
        
        req.user = { id: rows[0].id, role: rows[0].role };
        next();
    };
}
```

**Step 4: ë¡œê·¸ì•„ì›ƒ ì—”ë“œí¬ì¸íŠ¸ êµ¬í˜„**
```javascript
// server-backend/src/routes.js

import { blacklistAccessToken, blacklistRefreshToken } from './services/token-blacklist.js';
import { verifyToken, getAccessTTL, getRefreshTTL } from './auth/jwt.js';

// ë¡œê·¸ì•„ì›ƒ ì—”ë“œí¬ì¸íŠ¸
router.post('/api/auth/logout', async (req, res, next) => {
    try {
        const authHeader = req.headers.authorization;
        const { refreshToken } = req.body;
        
        // Access Token ë¸”ë™ë¦¬ìŠ¤íŠ¸ ì¶”ê°€
        if (authHeader && authHeader.startsWith('Bearer ')) {
            const accessToken = authHeader.substring(7);
            const accessPayload = verifyToken(accessToken, 'access');
            
            if (accessPayload && accessPayload.jti) {
                await blacklistAccessToken(
                    accessPayload.jti,
                    accessPayload.sub,
                    'user_logout',
                    getAccessTTL()
                );
            }
        }
        
        // Refresh Token ë¸”ë™ë¦¬ìŠ¤íŠ¸ ì¶”ê°€
        if (refreshToken) {
            const refreshPayload = verifyToken(refreshToken, 'refresh');
            
            if (refreshPayload && refreshPayload.jti) {
                await blacklistRefreshToken(
                    refreshPayload.jti,
                    refreshPayload.sub,
                    'user_logout',
                    getRefreshTTL()
                );
            }
        }
        
        res.json({ message: 'Logged out successfully' });
    } catch (error) {
        next(error);
    }
});

// ê°•ì œ ë¡œê·¸ì•„ì›ƒ (ê´€ë¦¬ììš©)
router.post('/api/admin/force-logout/:userId', requireAdmin, async (req, res, next) => {
    try {
        const { userId } = req.params;
        const { reason } = req.body;
        
        // ì‚¬ìš©ìì˜ ëª¨ë“  í™œì„± í† í° ë¬´íš¨í™”
        await blacklistAllUserTokens(userId, reason || 'admin_force_logout');
        
        res.json({ message: `User ${userId} forcefully logged out` });
    } catch (error) {
        next(error);
    }
});
```

**Step 5: Access Tokenì— JTI ì¶”ê°€**
```javascript
// server-backend/src/auth/jwt.js

export async function issueTokens(user) {
    const now = Math.floor(Date.now() / 1000);
    const accessJti = 'a_' + Math.random().toString(36).slice(2) + Date.now().toString(36);
    const refreshJti = 'r_' + Math.random().toString(36).slice(2) + Date.now().toString(36);

    // Access Tokenì—ë„ JTI ì¶”ê°€ (ë¸”ë™ë¦¬ìŠ¤íŠ¸ìš©)
    const accessPayload = {
        sub: String(user.id),
        role: user.role,
        typ: 'access',
        jti: accessJti, // ì¶”ê°€!
        iat: now,
        iss: process.env.JWT_ISSUER || 'community-platform',
        aud: process.env.JWT_AUDIENCE || 'community-platform-users'
    };

    const refreshPayload = {
        sub: String(user.id),
        jti: refreshJti,
        typ: 'refresh',
        iat: now,
        iss: process.env.JWT_ISSUER || 'community-platform',
        aud: process.env.JWT_AUDIENCE || 'community-platform-users'
    };

    const access = jwt.sign(accessPayload, SECRET, {
        algorithm: 'HS256',
        expiresIn: ACCESS_TTL_SEC
    });

    const refresh = jwt.sign(refreshPayload, SECRET, {
        algorithm: 'HS256',
        expiresIn: REFRESH_TTL_SEC
    });

    if (isRedisEnabled()) {
        await storeRefresh(refreshJti, { userId: user.id }, REFRESH_TTL_SEC);
    } else {
        refreshStore.set(refreshJti, { userId: user.id, exp: now + REFRESH_TTL_SEC });
    }
    
    return { access, refresh, access_expires_in: ACCESS_TTL_SEC, refresh_expires_in: REFRESH_TTL_SEC };
}
```

#### êµ¬í˜„ ì²´í¬ë¦¬ìŠ¤íŠ¸
- [ ] `token-blacklist.js` ì„œë¹„ìŠ¤ ì‘ì„±
- [ ] Redis ë¸”ë™ë¦¬ìŠ¤íŠ¸ ìŠ¤í‚¤ë§ˆ êµ¬í˜„
- [ ] In-memory fallback êµ¬í˜„
- [ ] JWT ê²€ì¦ ë¯¸ë“¤ì›¨ì–´ì— ë¸”ë™ë¦¬ìŠ¤íŠ¸ ì²´í¬ ì¶”ê°€
- [ ] ë¡œê·¸ì•„ì›ƒ ì—”ë“œí¬ì¸íŠ¸ êµ¬í˜„
- [ ] ê°•ì œ ë¡œê·¸ì•„ì›ƒ ì—”ë“œí¬ì¸íŠ¸ êµ¬í˜„ (ê´€ë¦¬ììš©)
- [ ] Access Tokenì— JTI ì¶”ê°€
- [ ] í”„ë¡ íŠ¸ì—”ë“œ ë¡œê·¸ì•„ì›ƒ ë¡œì§ ì—…ë°ì´íŠ¸
- [ ] í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ ì‘ì„±

#### í…ŒìŠ¤íŠ¸ ì‹œë‚˜ë¦¬ì˜¤
1. **ì •ìƒ ë¡œê·¸ì•„ì›ƒ** â†’ Access Token ë¸”ë™ë¦¬ìŠ¤íŠ¸ ì¶”ê°€ â†’ ì´í›„ ìš”ì²­ 401
2. **Refresh Tokenìœ¼ë¡œ ì¬ë°œê¸‰ ì‹œë„** â†’ ë¸”ë™ë¦¬ìŠ¤íŠ¸ í™•ì¸ â†’ 401
3. **ê´€ë¦¬ì ê°•ì œ ë¡œê·¸ì•„ì›ƒ** â†’ ì‚¬ìš©ì ëª¨ë“  í† í° ë¬´íš¨í™”
4. **ë¸”ë™ë¦¬ìŠ¤íŠ¸ TTL ë§Œë£Œ** â†’ Redis ìë™ ì‚­ì œ í™•ì¸

---

### ğŸŸ¡ 2.3 ë©”ì‹œì§€ ì•”í˜¸í™” ê°•í™” (AES-GCM)

#### í˜„ì¬ ë¬¸ì œì 
```typescript
// frontend/src/utils/MessageEncryption.ts (í˜„ì¬)
const encrypted = CryptoJS.AES.encrypt(messageData, roomKey, {
    iv: iv,
    mode: CryptoJS.mode.CBC, // âš ï¸ CBC ëª¨ë“œ (ì¸ì¦ ì—†ìŒ)
    padding: CryptoJS.pad.Pkcs7
});
```

**ë³´ì•ˆ ìœ„í—˜**:
- âœ— CBC ëª¨ë“œëŠ” ë©”ì‹œì§€ ì¸ì¦(Authentication) ë¯¸ì œê³µ
- âœ— ê³µê²©ìê°€ ì•”í˜¸ë¬¸ì„ ë³€ì¡°í•´ë„ íƒì§€ ë¶ˆê°€
- âœ— Padding Oracle Attack ê°€ëŠ¥ì„±
- âœ— í‚¤ êµí™˜ ë©”ì»¤ë‹ˆì¦˜ ë¶€ì¬

#### ê°œì„  ë°©ì•ˆ

**Step 1: Web Crypto API ì‚¬ìš© (AES-GCM)**
```typescript
// frontend/src/utils/MessageEncryption.ts (ê°œì„ )

export class MessageEncryptionV2 {
    private static readonly ALGORITHM = 'AES-GCM';
    private static readonly KEY_LENGTH = 256;
    private static readonly IV_LENGTH = 12; // GCM ê¶Œì¥ IV í¬ê¸°
    private static readonly TAG_LENGTH = 128; // ì¸ì¦ íƒœê·¸ í¬ê¸° (bits)

    /**
     * ë©”ì‹œì§€ ì•”í˜¸í™” (AES-256-GCM)
     */
    static async encryptMessage(
        content: string,
        roomKey: CryptoKey
    ): Promise<EncryptedMessage> {
        try {
            // ëœë¤ IV ìƒì„± (12 bytes for GCM)
            const iv = crypto.getRandomValues(new Uint8Array(this.IV_LENGTH));

            // ë©”ì‹œì§€ ID ë° íƒ€ì„ìŠ¤íƒ¬í”„
            const messageId = this.generateMessageId();
            const timestamp = Date.now();

            // ë©”ì‹œì§€ ë°ì´í„° ì§ë ¬í™”
            const messageData = JSON.stringify({
                content,
                timestamp,
                messageId
            });

            const encoder = new TextEncoder();
            const data = encoder.encode(messageData);

            // AES-GCM ì•”í˜¸í™” (ì¸ì¦ íƒœê·¸ ìë™ ìƒì„±)
            const encryptedData = await crypto.subtle.encrypt(
                {
                    name: this.ALGORITHM,
                    iv: iv,
                    tagLength: this.TAG_LENGTH
                },
                roomKey,
                data
            );

            return {
                encryptedContent: this.arrayBufferToBase64(encryptedData),
                iv: this.arrayBufferToBase64(iv),
                timestamp,
                messageId
            };
        } catch (error) {
            console.error('ë©”ì‹œì§€ ì•”í˜¸í™” ì‹¤íŒ¨:', error);
            throw new Error('ë©”ì‹œì§€ ì•”í˜¸í™”ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
        }
    }

    /**
     * ë©”ì‹œì§€ ë³µí˜¸í™” (AES-256-GCM)
     */
    static async decryptMessage(
        encryptedMessage: EncryptedMessage,
        roomKey: CryptoKey
    ): Promise<DecryptedMessage> {
        try {
            // IV ë³µì›
            const iv = this.base64ToArrayBuffer(encryptedMessage.iv);

            // ì•”í˜¸í™”ëœ ë°ì´í„° ë³µì›
            const encryptedData = this.base64ToArrayBuffer(encryptedMessage.encryptedContent);

            // AES-GCM ë³µí˜¸í™” (ì¸ì¦ íƒœê·¸ ìë™ ê²€ì¦)
            const decryptedData = await crypto.subtle.decrypt(
                {
                    name: this.ALGORITHM,
                    iv: iv,
                    tagLength: this.TAG_LENGTH
                },
                roomKey,
                encryptedData
            );

            const decoder = new TextDecoder();
            const decryptedString = decoder.decode(decryptedData);

            const messageData = JSON.parse(decryptedString);

            return {
                content: messageData.content,
                timestamp: messageData.timestamp,
                messageId: messageData.messageId,
                isEncrypted: true,
                isAuthenticated: true // GCM ì¸ì¦ ì„±ê³µ
            };
        } catch (error) {
            console.error('ë©”ì‹œì§€ ë³µí˜¸í™” ì‹¤íŒ¨:', error);
            
            // ì¸ì¦ ì‹¤íŒ¨ (ë³€ì¡°ëœ ë©”ì‹œì§€)
            if (error.name === 'OperationError') {
                throw new Error('ë©”ì‹œì§€ ì¸ì¦ ì‹¤íŒ¨: ë©”ì‹œì§€ê°€ ë³€ì¡°ë˜ì—ˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
            }
            
            throw new Error('ë©”ì‹œì§€ ë³µí˜¸í™”ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
        }
    }

    /**
     * ì±„íŒ…ë°© í‚¤ ìƒì„±
     */
    static async generateRoomKey(): Promise<CryptoKey> {
        return await crypto.subtle.generateKey(
            {
                name: this.ALGORITHM,
                length: this.KEY_LENGTH
            },
            true, // extractable (í‚¤ êµí™˜ìš©)
            ['encrypt', 'decrypt']
        );
    }

    /**
     * í‚¤ë¥¼ Base64ë¡œ ë‚´ë³´ë‚´ê¸° (ì„œë²„ ì „ì†¡ìš©)
     */
    static async exportKey(key: CryptoKey): Promise<string> {
        const exported = await crypto.subtle.exportKey('raw', key);
        return this.arrayBufferToBase64(exported);
    }

    /**
     * Base64 í‚¤ë¥¼ CryptoKeyë¡œ ê°€ì ¸ì˜¤ê¸°
     */
    static async importKey(keyBase64: string): Promise<CryptoKey> {
        const keyData = this.base64ToArrayBuffer(keyBase64);
        return await crypto.subtle.importKey(
            'raw',
            keyData,
            {
                name: this.ALGORITHM,
                length: this.KEY_LENGTH
            },
            true,
            ['encrypt', 'decrypt']
        );
    }

    // Utility methods
    private static arrayBufferToBase64(buffer: ArrayBuffer): string {
        const bytes = new Uint8Array(buffer);
        let binary = '';
        for (let i = 0; i < bytes.byteLength; i++) {
            binary += String.fromCharCode(bytes[i]);
        }
        return btoa(binary);
    }

    private static base64ToArrayBuffer(base64: string): ArrayBuffer {
        const binary = atob(base64);
        const bytes = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i++) {
            bytes[i] = binary.charCodeAt(i);
        }
        return bytes.buffer;
    }

    private static generateMessageId(): string {
        const array = new Uint8Array(16);
        crypto.getRandomValues(array);
        return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
    }
}
```

**Step 2: Diffie-Hellman í‚¤ êµí™˜ êµ¬í˜„**
```typescript
// frontend/src/utils/KeyExchange.ts

export class DHKeyExchange {
    /**
     * ECDH í‚¤ ìŒ ìƒì„±
     */
    static async generateKeyPair(): Promise<CryptoKeyPair> {
        return await crypto.subtle.generateKey(
            {
                name: 'ECDH',
                namedCurve: 'P-256' // 256-bit íƒ€ì›ê³¡ì„ 
            },
            true,
            ['deriveKey']
        );
    }

    /**
     * ê³µê°œ í‚¤ ë‚´ë³´ë‚´ê¸° (ìƒëŒ€ë°©ì—ê²Œ ì „ì†¡)
     */
    static async exportPublicKey(publicKey: CryptoKey): Promise<string> {
        const exported = await crypto.subtle.exportKey('spki', publicKey);
        return this.arrayBufferToBase64(exported);
    }

    /**
     * ê³µê°œ í‚¤ ê°€ì ¸ì˜¤ê¸° (ìƒëŒ€ë°©ìœ¼ë¡œë¶€í„° ìˆ˜ì‹ )
     */
    static async importPublicKey(publicKeyBase64: string): Promise<CryptoKey> {
        const keyData = this.base64ToArrayBuffer(publicKeyBase64);
        return await crypto.subtle.importKey(
            'spki',
            keyData,
            {
                name: 'ECDH',
                namedCurve: 'P-256'
            },
            true,
            []
        );
    }

    /**
     * ê³µìœ  ë¹„ë°€ í‚¤ ìƒì„± (ë‚´ ê°œì¸ í‚¤ + ìƒëŒ€ë°© ê³µê°œ í‚¤)
     */
    static async deriveSharedSecret(
        myPrivateKey: CryptoKey,
        theirPublicKey: CryptoKey
    ): Promise<CryptoKey> {
        return await crypto.subtle.deriveKey(
            {
                name: 'ECDH',
                public: theirPublicKey
            },
            myPrivateKey,
            {
                name: 'AES-GCM',
                length: 256
            },
            true,
            ['encrypt', 'decrypt']
        );
    }

    // Utility methods
    private static arrayBufferToBase64(buffer: ArrayBuffer): string {
        const bytes = new Uint8Array(buffer);
        let binary = '';
        for (let i = 0; i < bytes.byteLength; i++) {
            binary += String.fromCharCode(bytes[i]);
        }
        return btoa(binary);
    }

    private static base64ToArrayBuffer(base64: string): ArrayBuffer {
        const binary = atob(base64);
        const bytes = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i++) {
            bytes[i] = binary.charCodeAt(i);
        }
        return bytes.buffer;
    }
}
```

**Step 3: ì±„íŒ…ë°© ì°¸ì—¬ ì‹œ í‚¤ êµí™˜ í”„ë¡œí† ì½œ**
```typescript
// frontend/src/services/ChatService.ts

export class ChatService {
    private roomKeys: Map<string, CryptoKey> = new Map();
    private myKeyPairs: Map<string, CryptoKeyPair> = new Map();

    /**
     * ì±„íŒ…ë°© ì°¸ì—¬ ë° í‚¤ êµí™˜
     */
    async joinRoom(roomId: string): Promise<void> {
        // 1. ë‚´ ECDH í‚¤ ìŒ ìƒì„±
        const myKeyPair = await DHKeyExchange.generateKeyPair();
        this.myKeyPairs.set(roomId, myKeyPair);

        // 2. ë‚´ ê³µê°œ í‚¤ë¥¼ ì„œë²„ì— ì „ì†¡
        const myPublicKey = await DHKeyExchange.exportPublicKey(myKeyPair.publicKey);
        const response = await apiClient.post(`/api/chat/rooms/${roomId}/join`, {
            publicKey: myPublicKey
        });

        // 3. ì„œë²„ë¡œë¶€í„° ë‹¤ë¥¸ ì°¸ì—¬ìì˜ ê³µê°œ í‚¤ ìˆ˜ì‹ 
        const otherParticipants = response.data.participants;

        // 4. ê° ì°¸ì—¬ìì™€ ê³µìœ  ë¹„ë°€ í‚¤ ìƒì„±
        for (const participant of otherParticipants) {
            const theirPublicKey = await DHKeyExchange.importPublicKey(participant.publicKey);
            const sharedSecret = await DHKeyExchange.deriveSharedSecret(
                myKeyPair.privateKey,
                theirPublicKey
            );

            // 5. ì±„íŒ…ë°© í‚¤ë¡œ ì €ì¥
            this.roomKeys.set(roomId, sharedSecret);
            console.log(`âœ… Shared secret established for room ${roomId}`);
        }
    }

    /**
     * ë©”ì‹œì§€ ì „ì†¡ (ì•”í˜¸í™”)
     */
    async sendMessage(roomId: string, content: string): Promise<void> {
        const roomKey = this.roomKeys.get(roomId);
        if (!roomKey) {
            throw new Error('Room key not found. Please join the room first.');
        }

        const encryptedMessage = await MessageEncryptionV2.encryptMessage(content, roomKey);

        await apiClient.post(`/api/chat/rooms/${roomId}/messages`, {
            encrypted: encryptedMessage
        });
    }

    /**
     * ë©”ì‹œì§€ ìˆ˜ì‹  (ë³µí˜¸í™”)
     */
    async receiveMessage(roomId: string, encryptedMessage: EncryptedMessage): Promise<string> {
        const roomKey = this.roomKeys.get(roomId);
        if (!roomKey) {
            throw new Error('Room key not found.');
        }

        const decrypted = await MessageEncryptionV2.decryptMessage(encryptedMessage, roomKey);
        return decrypted.content;
    }
}
```

#### êµ¬í˜„ ì²´í¬ë¦¬ìŠ¤íŠ¸
- [ ] `MessageEncryptionV2.ts` ì‘ì„± (AES-GCM)
- [ ] `KeyExchange.ts` ì‘ì„± (ECDH)
- [ ] `ChatService.ts` ìˆ˜ì • (í‚¤ êµí™˜ í”„ë¡œí† ì½œ)
- [ ] ì„œë²„ ì¸¡ ê³µê°œ í‚¤ ì €ì¥ ë° êµí™˜ ì—”ë“œí¬ì¸íŠ¸ êµ¬í˜„
- [ ] ê¸°ì¡´ CBC ì•”í˜¸í™” ì½”ë“œ ë§ˆì´ê·¸ë ˆì´ì…˜
- [ ] ì—ëŸ¬ ì²˜ë¦¬ ë° ì¬ì‹œë„ ë¡œì§ ì¶”ê°€
- [ ] í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ ì‘ì„±

#### í…ŒìŠ¤íŠ¸ ì‹œë‚˜ë¦¬ì˜¤
1. **ì •ìƒ ì•”í˜¸í™”/ë³µí˜¸í™”** â†’ âœ… ë©”ì‹œì§€ ì •ìƒ ì†¡ìˆ˜ì‹ 
2. **ë³€ì¡°ëœ ì•”í˜¸ë¬¸** â†’ âŒ ì¸ì¦ ì‹¤íŒ¨ ì—ëŸ¬
3. **ì˜ëª»ëœ í‚¤ë¡œ ë³µí˜¸í™”** â†’ âŒ ì¸ì¦ ì‹¤íŒ¨ ì—ëŸ¬
4. **í‚¤ êµí™˜ ì‹¤íŒ¨** â†’ âŒ ë©”ì‹œì§€ ì „ì†¡ ë¶ˆê°€

---

### ğŸŸ¡ 2.4 CSRF í† í° ì™„ì „ êµ¬í˜„

#### í˜„ì¬ ë¬¸ì œì 
```javascript
// server-backend/src/middleware/security.js (í˜„ì¬)
const csrfProtection = (req, res, next) => {
    if (req.method === 'GET') {
        return next();
    }
    
    const csrfToken = req.headers['x-csrf-token'];
    const sessionToken = req.session?.csrfToken; // âš ï¸ ì„¸ì…˜ ê¸°ë°˜ (JWT ì‚¬ìš© ì‹œ ë¬¸ì œ)
    
    if (!csrfToken || !sessionToken || csrfToken !== sessionToken) {
        return res.status(403).json({ error: 'Invalid CSRF token' });
    }
    
    next();
};
```

**ë³´ì•ˆ ìœ„í—˜**:
- âœ— CSRF í† í° ìƒì„± ë¡œì§ ì—†ìŒ
- âœ— JWT ì¸ì¦ ì‚¬ìš© ì‹œ ì„¸ì…˜ ì—†ì„ ìˆ˜ ìˆìŒ
- âœ— Double Submit Cookie íŒ¨í„´ ë¯¸êµ¬í˜„

#### ê°œì„  ë°©ì•ˆ

**Step 1: CSRF í† í° ìƒì„± ìœ í‹¸ë¦¬í‹°**
```javascript
// server-backend/src/utils/csrf.js

const crypto = require('crypto');

/**
 * CSRF í† í° ìƒì„±
 */
function generateCsrfToken() {
    return crypto.randomBytes(32).toString('hex');
}

/**
 * CSRF í† í° ê²€ì¦ (íƒ€ì´ë° ê³µê²© ë°©ì§€)
 */
function verifyCsrfToken(token1, token2) {
    if (!token1 || !token2) return false;
    if (token1.length !== token2.length) return false;
    
    // íƒ€ì´ë° ê³µê²© ë°©ì§€ë¥¼ ìœ„í•œ constant-time ë¹„êµ
    return crypto.timingSafeEqual(
        Buffer.from(token1),
        Buffer.from(token2)
    );
}

module.exports = { generateCsrfToken, verifyCsrfToken };
```

**Step 2: CSRF í† í° ë°œê¸‰ ì—”ë“œí¬ì¸íŠ¸**
```javascript
// server-backend/src/routes.js

import { generateCsrfToken } from './utils/csrf.js';

// CSRF í† í° ë°œê¸‰ (ë¡œê·¸ì¸ ì‹œ ìë™ ë°œê¸‰)
router.get('/api/csrf-token', (req, res) => {
    const csrfToken = generateCsrfToken();
    
    // Double Submit Cookie íŒ¨í„´
    res.cookie('XSRF-TOKEN', csrfToken, {
        httpOnly: false, // JavaScriptì—ì„œ ì½ì„ ìˆ˜ ìˆë„ë¡
        secure: process.env.NODE_ENV === 'production', // HTTPS only in production
        sameSite: 'strict',
        maxAge: 24 * 60 * 60 * 1000 // 24ì‹œê°„
    });
    
    res.json({ csrfToken });
});
```

**Step 3: CSRF ë³´í˜¸ ë¯¸ë“¤ì›¨ì–´ ê°œì„ **
```javascript
// server-backend/src/middleware/security.js

const { verifyCsrfToken } = require('../utils/csrf');

/**
 * CSRF ë³´í˜¸ ë¯¸ë“¤ì›¨ì–´ (Double Submit Cookie íŒ¨í„´)
 */
const csrfProtection = (req, res, next) => {
    // GET, HEAD, OPTIONS ìš”ì²­ì€ ì œì™¸
    if (['GET', 'HEAD', 'OPTIONS'].includes(req.method)) {
        return next();
    }
    
    // CSRF í† í° í™•ì¸
    const tokenFromHeader = req.headers['x-csrf-token'];
    const tokenFromCookie = req.cookies['XSRF-TOKEN'];
    
    if (!tokenFromHeader || !tokenFromCookie) {
        console.warn('âš ï¸ CSRF token missing:', {
            header: !!tokenFromHeader,
            cookie: !!tokenFromCookie,
            method: req.method,
            path: req.path,
            ip: req.ip
        });
        
        return res.status(403).json({
            error: 'CSRF token missing',
            code: 'CSRF_TOKEN_MISSING'
        });
    }
    
    // íƒ€ì´ë° ê³µê²© ë°©ì§€ ë¹„êµ
    if (!verifyCsrfToken(tokenFromHeader, tokenFromCookie)) {
        console.warn('âš ï¸ CSRF token mismatch:', {
            method: req.method,
            path: req.path,
            ip: req.ip
        });
        
        return res.status(403).json({
            error: 'Invalid CSRF token',
            code: 'CSRF_TOKEN_INVALID'
        });
    }
    
    next();
};

/**
 * SameSite ì¿ í‚¤ ê¸°ë°˜ CSRF ë³´í˜¸ (JWT ì‚¬ìš© ì‹œ)
 */
const csrfProtectionJWT = (req, res, next) => {
    // ì¤‘ìš” ì‘ì—…(ì‚­ì œ, ê²°ì œ ë“±)ì—ë§Œ CSRF í† í° ìš”êµ¬
    const criticalPaths = [
        '/api/posts/*/delete',
        '/api/users/delete',
        '/api/payments',
        '/api/admin/*'
    ];
    
    const isCriticalPath = criticalPaths.some(pattern => {
        const regex = new RegExp(pattern.replace('*', '.*'));
        return regex.test(req.path);
    });
    
    if (!isCriticalPath) {
        return next();
    }
    
    // ì¤‘ìš” ì‘ì—…ì€ CSRF í† í° ê²€ì¦
    return csrfProtection(req, res, next);
};

module.exports = {
    csrfProtection,
    csrfProtectionJWT
};
```

**Step 4: í”„ë¡ íŠ¸ì—”ë“œ CSRF í† í° ì²˜ë¦¬**
```typescript
// frontend/src/services/apiClient.ts

class APIClient {
    private csrfToken: string | null = null;

    constructor() {
        this.fetchCsrfToken();
    }

    /**
     * CSRF í† í° ê°€ì ¸ì˜¤ê¸°
     */
    private async fetchCsrfToken(): Promise<void> {
        try {
            const response = await fetch('/api/csrf-token', {
                credentials: 'include' // ì¿ í‚¤ í¬í•¨
            });
            const data = await response.json();
            this.csrfToken = data.csrfToken;
            console.log('âœ… CSRF token fetched');
        } catch (error) {
            console.error('âŒ Failed to fetch CSRF token:', error);
        }
    }

    /**
     * API ìš”ì²­
     */
    async request(method: string, url: string, data?: any): Promise<any> {
        const headers: Record<string, string> = {
            'Content-Type': 'application/json'
        };

        // POST, PUT, DELETE ìš”ì²­ì— CSRF í† í° ì¶”ê°€
        if (['POST', 'PUT', 'DELETE', 'PATCH'].includes(method)) {
            if (!this.csrfToken) {
                await this.fetchCsrfToken();
            }
            headers['X-CSRF-Token'] = this.csrfToken!;
        }

        const response = await fetch(url, {
            method,
            headers,
            body: data ? JSON.stringify(data) : undefined,
            credentials: 'include' // ì¿ í‚¤ í¬í•¨
        });

        if (!response.ok) {
            const error = await response.json();
            
            // CSRF í† í° ë§Œë£Œ ì‹œ ì¬ë°œê¸‰
            if (error.code === 'CSRF_TOKEN_INVALID' || error.code === 'CSRF_TOKEN_MISSING') {
                await this.fetchCsrfToken();
                // ì¬ì‹œë„
                return this.request(method, url, data);
            }
            
            throw new Error(error.error || 'Request failed');
        }

        return response.json();
    }

    // Convenience methods
    get(url: string) {
        return this.request('GET', url);
    }

    post(url: string, data: any) {
        return this.request('POST', url, data);
    }

    put(url: string, data: any) {
        return this.request('PUT', url, data);
    }

    delete(url: string) {
        return this.request('DELETE', url);
    }
}

export const apiClient = new APIClient();
```

**Step 5: Express ì•±ì— CSRF ë¯¸ë“¤ì›¨ì–´ ì ìš©**
```javascript
// server-backend/src/server.js

import { csrfProtectionJWT } from './middleware/security.js';
import cookieParser from 'cookie-parser';

const app = express();

// Cookie parser (CSRF í† í° ì½ê¸°ìš©)
app.use(cookieParser());

// CSRF ë³´í˜¸ ì ìš© (JWT í™˜ê²½ì— ìµœì í™”)
app.use(csrfProtectionJWT);
```

#### êµ¬í˜„ ì²´í¬ë¦¬ìŠ¤íŠ¸
- [ ] `csrf.js` ìœ í‹¸ë¦¬í‹° ì‘ì„±
- [ ] CSRF í† í° ë°œê¸‰ ì—”ë“œí¬ì¸íŠ¸ ì¶”ê°€
- [ ] CSRF ë³´í˜¸ ë¯¸ë“¤ì›¨ì–´ ê°œì„ 
- [ ] JWT í™˜ê²½ìš© CSRF ë¯¸ë“¤ì›¨ì–´ ì‘ì„±
- [ ] í”„ë¡ íŠ¸ì—”ë“œ `apiClient.ts` ìˆ˜ì •
- [ ] ì¤‘ìš” ê²½ë¡œ CSRF ê²€ì¦ ê°•í™”
- [ ] í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ ì‘ì„±

#### í…ŒìŠ¤íŠ¸ ì‹œë‚˜ë¦¬ì˜¤
1. **CSRF í† í° ì—†ì´ POST ìš”ì²­** â†’ âŒ 403 Forbidden
2. **ì˜ëª»ëœ CSRF í† í°ìœ¼ë¡œ POST ìš”ì²­** â†’ âŒ 403 Forbidden
3. **ìœ íš¨í•œ CSRF í† í°ìœ¼ë¡œ POST ìš”ì²­** â†’ âœ… ì •ìƒ ì²˜ë¦¬
4. **GET ìš”ì²­** â†’ âœ… CSRF ê²€ì¦ ê±´ë„ˆëœ€

---

## 3. êµ¬í˜„ ì¼ì •

| ì£¼ì°¨                    | ì‘ì—… ë‚´ìš©                         | ë‹´ë‹¹             | ìƒíƒœ |
| ----------------------- | --------------------------------- | ---------------- | ---- |
| **1ì£¼ì°¨ (11/11-11/15)** |                                   |                  |      |
| ì›”                      | JWT Secret í™˜ê²½ ë³€ìˆ˜ í•„ìˆ˜í™”       | Backend          | â³    |
| í™”-ìˆ˜                   | í† í° ë¸”ë™ë¦¬ìŠ¤íŠ¸ êµ¬í˜„ (Redis)      | Backend          | â³    |
| ëª©                      | í† í° ë¸”ë™ë¦¬ìŠ¤íŠ¸ í…ŒìŠ¤íŠ¸ ë° ë¬¸ì„œí™”  | Backend          | â³    |
| ê¸ˆ                      | ë©”ì‹œì§€ ì•”í˜¸í™” ê°•í™” (AES-GCM) ì‹œì‘ | Frontend         | â³    |
| **2ì£¼ì°¨ (11/18-11/22)** |                                   |                  |      |
| ì›”                      | ë©”ì‹œì§€ ì•”í˜¸í™” ê°•í™” ì™„ë£Œ           | Frontend         | â³    |
| í™”                      | í‚¤ êµí™˜ í”„ë¡œí† ì½œ êµ¬í˜„ (ECDH)      | Frontend/Backend | â³    |
| ìˆ˜                      | CSRF í† í° ì™„ì „ êµ¬í˜„               | Backend/Frontend | â³    |
| ëª©-ê¸ˆ                   | í†µí•© í…ŒìŠ¤íŠ¸ ë° ë°°í¬               | All              | â³    |

---

## 4. í…ŒìŠ¤íŠ¸ ê³„íš

### 4.1 ë‹¨ìœ„ í…ŒìŠ¤íŠ¸
```javascript
// server-backend/tests/security-urgent.test.js

describe('ê¸´ê¸‰ ë³´ì•ˆ ê°œì„  í…ŒìŠ¤íŠ¸', () => {
    describe('JWT Secret ê²€ì¦', () => {
        it('í™˜ê²½ ë³€ìˆ˜ ì—†ì´ ì„œë²„ ì‹œì‘ ì‹œ ì¢…ë£Œë˜ì–´ì•¼ í•¨', () => {
            // ...
        });
        
        it('ì§§ì€ Secret ì„¤ì • ì‹œ ì¢…ë£Œë˜ì–´ì•¼ í•¨', () => {
            // ...
        });
    });
    
    describe('í† í° ë¸”ë™ë¦¬ìŠ¤íŠ¸', () => {
        it('ë¡œê·¸ì•„ì›ƒ í›„ Access Token ì‚¬ìš© ë¶ˆê°€', async () => {
            // ...
        });
        
        it('ë¸”ë™ë¦¬ìŠ¤íŠ¸ TTL ë§Œë£Œ í›„ ìë™ ì‚­ì œ', async () => {
            // ...
        });
    });
    
    describe('AES-GCM ì•”í˜¸í™”', () => {
        it('ì •ìƒ ì•”í˜¸í™”/ë³µí˜¸í™”', async () => {
            // ...
        });
        
        it('ë³€ì¡°ëœ ì•”í˜¸ë¬¸ ë³µí˜¸í™” ì‹œ ì—ëŸ¬', async () => {
            // ...
        });
    });
    
    describe('CSRF ë³´í˜¸', () => {
        it('CSRF í† í° ì—†ì´ POST ìš”ì²­ ì‹œ 403', async () => {
            // ...
        });
        
        it('ìœ íš¨í•œ CSRF í† í°ìœ¼ë¡œ POST ìš”ì²­ ì„±ê³µ', async () => {
            // ...
        });
    });
});
```

### 4.2 í†µí•© í…ŒìŠ¤íŠ¸
- Playwright E2E í…ŒìŠ¤íŠ¸ì— ë³´ì•ˆ ì‹œë‚˜ë¦¬ì˜¤ ì¶”ê°€
- ì‹¤ì œ ì‚¬ìš©ì í”Œë¡œìš° í…ŒìŠ¤íŠ¸ (ë¡œê·¸ì¸, ë¡œê·¸ì•„ì›ƒ, ë©”ì‹œì§€ ì „ì†¡)

### 4.3 ë³´ì•ˆ ê°ì‚¬
- OWASP ZAP ìë™í™” ìŠ¤ìº”
- ì¹¨íˆ¬ í…ŒìŠ¤íŠ¸ (ì™¸ë¶€ ì—…ì²´ ì˜ë¢°)

---

## 5. ë°°í¬ ì „ëµ

### 5.1 ë‹¨ê³„ë³„ ë°°í¬
1. **Stage 1**: ê°œë°œ í™˜ê²½ ë°°í¬ ë° í…ŒìŠ¤íŠ¸
2. **Stage 2**: ìŠ¤í…Œì´ì§• í™˜ê²½ ë°°í¬ ë° ê²€ì¦
3. **Stage 3**: í”„ë¡œë•ì…˜ í™˜ê²½ ë°°í¬ (Blue-Green Deployment)

### 5.2 ë¡¤ë°± ê³„íš
- ê° ê°œì„  ì‚¬í•­ì€ ë…ë¦½ì ìœ¼ë¡œ ë¡¤ë°± ê°€ëŠ¥
- Feature Flag ì‚¬ìš© (ìƒˆë¡œìš´ ë³´ì•ˆ ê¸°ëŠ¥ í† ê¸€)

### 5.3 ëª¨ë‹ˆí„°ë§
- ë³´ì•ˆ ì´ë²¤íŠ¸ ë¡œê·¸ ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§
- ì—ëŸ¬ìœ¨ ì¶”ì  (Sentry, Datadog)
- ì„±ëŠ¥ ì˜í–¥ ì¸¡ì •

---

## 6. ë¬¸ì„œí™”

### 6.1 ê°œë°œì ë¬¸ì„œ
- [x] SECURITY_URGENT_IMPROVEMENTS.md (ë³¸ ë¬¸ì„œ)
- [ ] SECURITY_IMPLEMENTATION_GUIDE.md (êµ¬í˜„ ê°€ì´ë“œ)
- [ ] SECURITY_API_CHANGES.md (API ë³€ê²½ ì‚¬í•­)

### 6.2 ìš´ì˜ ë¬¸ì„œ
- [ ] DEPLOYMENT_CHECKLIST.md (ë°°í¬ ì²´í¬ë¦¬ìŠ¤íŠ¸)
- [ ] INCIDENT_RESPONSE.md (ë³´ì•ˆ ì‚¬ê³  ëŒ€ì‘ ì ˆì°¨)

---

**ì‘ì„±ì**: AUTOAGENTS  
**ê²€í† ì**: -  
**ìŠ¹ì¸ì**: -  
**ë‹¤ìŒ ê²€í† ì¼**: 2025ë…„ 11ì›” 16ì¼

**Note**: FirebaseëŠ” ì‚¬ìš©í•˜ì§€ ì•Šìœ¼ë©°, JWT ê¸°ë°˜ ì¸ì¦ë§Œ ì‚¬ìš©í•©ë‹ˆë‹¤.
